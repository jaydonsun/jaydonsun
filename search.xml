<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux学习 第十五天</title>
      <link href="linux-xue-xi-di-shi-wu-tian.html"/>
      <url>linux-xue-xi-di-shi-wu-tian.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用DHCP动态管理主机地址"><a href="#使用DHCP动态管理主机地址" class="headerlink" title="使用DHCP动态管理主机地址"></a>使用DHCP动态管理主机地址</h1><p>动态主机配置协议（DHCP，Dynamic Host Configuration Protocol），该协议用于自动管理局域网内主机的IP地址、子网掩码、网关地址及DNS地址等参数，可以有效地提升IP地址的利用率，提高配置效率，并降低管理与维护成本。</p><blockquote><p><strong>作用域</strong>：一个完整的IP地址段，DHCP协议根据作用域来管理网络的分布、分配IP地址及其他配置参数。</p><p><strong>超级作用域</strong>：用于管理处于同一个物理网络中的多个逻辑子网段。超级作用域中包含了可以统一管理的作用域列表。</p><p><strong>排除范围</strong>：把作用域中的某些IP地址排除，确保这些IP地址不会分配给DHCP客户端。</p><p><strong>地址池</strong>：在定义了DHCP的作用域并应用了排除范围后，剩余的用来动态分配给DHCP客户端的IP地址范围。</p><p><strong>租约</strong>：DHCP客户端能够使用动态分配的IP地址的时间。</p><p><strong>预约</strong>：保证网络中的特定设备总是获取到相同的IP地址。</p></blockquote><h3 id="安装dhcp"><a href="#安装dhcp" class="headerlink" title="安装dhcp"></a>安装dhcp</h3><p>yum install dhcp  安装dhcp服务</p><p>dhcpd服务程序配置文件中使用的常见参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>ddns-update-style 类型</td><td>定义DNS服务动态更新的类型，类型包括： none（不支持动态更新）、interim（互动更新模式）与ad-hoc（特殊更新模式）</td></tr><tr><td>allow/ignore client-updates</td><td>允许/忽略客户端更新DNS记录</td></tr><tr><td>default-lease-time 21600</td><td>默认超时时间</td></tr><tr><td>max-lease-time 43200</td><td>最大超时时间</td></tr><tr><td>option domain-name-servers 8.8.8.8</td><td>定义DNS服务器地址</td></tr><tr><td>option domain-name “domain.org”</td><td>定义DNS域名</td></tr><tr><td>range</td><td>定义用于分配的IP地址池</td></tr><tr><td>option subnet-mask</td><td>定义客户端的子网掩码</td></tr><tr><td>option routers</td><td>定义客户端的网关地址</td></tr><tr><td>broadcast-address 广播地址</td><td>定义客户端的广播地址</td></tr><tr><td>ntp-server IP地址</td><td>定义客户端的网络时间服务器（NTP）</td></tr><tr><td>nis-servers IP地址</td><td>定义客户端的NIS域服务器的地址</td></tr><tr><td>hardware 硬件类型 MAC地址</td><td>指定网卡接口的类型与MAC地址</td></tr><tr><td>server-name 主机名</td><td>向DHCP客户端通知DHCP服务器的主机名</td></tr><tr><td>fixed-address IP地址</td><td>将某个固定的IP地址分配给指定主机</td></tr><tr><td>time-offset 偏移差</td><td>指定客户端与格林尼治时间的偏移差</td></tr></tbody></table><h3 id="自动管理IP地址"><a href="#自动管理IP地址" class="headerlink" title="自动管理IP地址"></a>自动管理IP地址</h3><p>DHCP协议的设计初衷是为了更高效地集中管理局域网内的IP地址资源。DHCP服务器会自动把IP地址、子网掩码、网关、DNS地址等网络信息分配给有需要的客户端，而且当客户端的租约时间到期后还可以自动回收所分配的IP地址，以便交给新加入的客户端。</p><p>dhcpd服务程序配置文件中使用的参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>ddns-update-style none;</td><td>设置DNS服务不自动进行动态更新</td></tr><tr><td>ignore client-updates;</td><td>忽略客户端更新DNS记录</td></tr><tr><td>subnet 192.168.10.0 netmask 255.255.255.0 {</td><td>作用域为192.168.10.0/24网段</td></tr><tr><td>range 192.168.10.50 192.168.10.150;</td><td>IP地址池为192.168.10.50-150（约100个IP地址）</td></tr><tr><td>option subnet-mask 255.255.255.0;</td><td>定义客户端默认的子网掩码</td></tr><tr><td>option routers 192.168.10.1;</td><td>定义客户端的网关地址</td></tr><tr><td>option domain-name “linuxprobe.com”;</td><td>定义默认的搜索域</td></tr><tr><td>option domain-name-servers 192.168.10.1;</td><td>定义客户端的DNS地址</td></tr><tr><td>default-lease-time 21600;</td><td>定义默认租约时间（单位：秒）</td></tr><tr><td>max-lease-time 43200;</td><td>定义最大预约时间（单位：秒）</td></tr><tr><td>}</td><td>结束符</td></tr></tbody></table><h3 id="分配固定IP地址"><a href="#分配固定IP地址" class="headerlink" title="分配固定IP地址"></a>分配固定IP地址</h3><p>在DHCP协议中有个术语是“预约”，它用来确保局域网中特定的设备总是获取到固定的IP地址。换句话说，就是dhcpd服务程序会把某个IP地址私藏下来，只将其用于相匹配的特定设备。</p><p>要想把某个IP地址与某台主机进行绑定，就需要用到这台主机的MAC地址。MAC地址是网卡上面的一串独立的标识符，具备唯一性，因此不会存在冲突的情况，</p><p>在Linux系统或Windows系统中，都可以通过查看网卡的状态来获知主机的MAC地址。在dhcpd服务程序的配置文件中，按照如下格式将IP地址与MAC地址进行绑定。</p><table><thead><tr><th>host 主机名称 {</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>hardware</td><td>ethernet</td><td>该主机的MAC地址;</td><td></td></tr><tr><td></td><td>fixed-address</td><td>欲指定的IP地址;</td><td></td><td></td></tr><tr><td>}</td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习 第十四天</title>
      <link href="linux-xue-xi-di-shi-si-tian.html"/>
      <url>linux-xue-xi-di-shi-si-tian.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用Samba或NFS实现文件共享"><a href="#使用Samba或NFS实现文件共享" class="headerlink" title="使用Samba或NFS实现文件共享"></a>使用Samba或NFS实现文件共享</h1><h2 id="Samba文件共享服务"><a href="#Samba文件共享服务" class="headerlink" title="Samba文件共享服务"></a>Samba文件共享服务</h2><p>yum install samba   安装samba</p><p>/etc/samba/smb.conf  主配置文件</p><p>由于在Samba服务程序的主配置文件中，注释信息行实在太多，不便于分析里面的重要参数，因此先把主配置文件改个名字，然后使用cat命令读入主配置文件，再在grep命令后面添加-v参数（反向选择），分别去掉所有以井号（#）和分号（;）开头的注释信息行，对于剩余的空白行可以使用^$参数来表示并进行反选过滤，最后把过滤后的可用参数信息通过重定向符覆盖写入到原始文件名称中。</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# mv /etc/samba/smb.conf /etc/samba/smb.conf.bak[root@linuxprobe ~]# cat /etc/samba/smb.conf.bak | grep -v "#" | grep -v ";" | grep -v "^$" > /etc/samba/smb.conf[root@linuxprobe ~]# cat /etc/samba/smb.conf</code></pre><p> Samba服务程序中的参数以及作用</p><table><thead><tr><th>[global]</th><th></th><th>#全局参数。</th></tr></thead><tbody><tr><td></td><td>workgroup = MYGROUP</td><td>#工作组名称</td></tr><tr><td></td><td>server string = Samba Server Version %v</td><td>#服务器介绍信息，参数%v为显示SMB版本号</td></tr><tr><td></td><td>log file = /var/log/samba/log.%m</td><td>#定义日志文件的存放位置与名称，参数%m为来访的主机名</td></tr><tr><td></td><td>max log size = 50</td><td>#定义日志文件的最大容量为50KB</td></tr><tr><td></td><td>security = user</td><td>#安全验证的方式，总共有4种</td></tr><tr><td></td><td>#share：来访主机无需验证口令；比较方便，但安全性很差</td><td></td></tr><tr><td></td><td>#user：需验证来访主机提供的口令后才可以访问；提升了安全性</td><td></td></tr><tr><td></td><td>#server：使用独立的远程主机验证来访主机提供的口令（集中管理账户）</td><td></td></tr><tr><td></td><td>#domain：使用域控制器进行身份验证</td><td></td></tr><tr><td></td><td>passdb backend = tdbsam</td><td>#定义用户后台的类型，共有3种</td></tr><tr><td></td><td>#smbpasswd：使用smbpasswd命令为系统用户设置Samba服务程序的密码</td><td></td></tr><tr><td></td><td>#tdbsam：创建数据库文件并使用pdbedit命令建立Samba服务程序的用户</td><td></td></tr><tr><td></td><td>#ldapsam：基于LDAP服务进行账户验证</td><td></td></tr><tr><td></td><td>load printers = yes</td><td>#设置在Samba服务启动时是否共享打印机设备</td></tr><tr><td></td><td>cups options = raw</td><td>#打印机的选项</td></tr><tr><td>[homes]</td><td></td><td>#共享参数</td></tr><tr><td></td><td>comment = Home Directories</td><td>#描述信息</td></tr><tr><td></td><td>browseable = no</td><td>#指定共享信息是否在“网上邻居”中可见</td></tr><tr><td></td><td>writable = yes</td><td>#定义是否可以执行写入操作，与“read only”相反</td></tr><tr><td>[printers]</td><td></td><td>#打印机共享参数</td></tr><tr><td></td><td>comment = All Printers</td><td></td></tr><tr><td></td><td>path = /var/spool/samba</td><td>#共享文件的实际路径(重要)。</td></tr><tr><td></td><td>browseable = no</td><td></td></tr><tr><td></td><td>guest ok = no</td><td>#是否所有人可见，等同于”public”参数。</td></tr><tr><td></td><td>writable = no</td><td></td></tr><tr><td></td><td>printable = yes</td><td></td></tr></tbody></table><h3 id="配置共享资源"><a href="#配置共享资源" class="headerlink" title="配置共享资源"></a>配置共享资源</h3><p>Samba服务程序的主配置文件与前面学习过的Apache服务很相似，包括全局配置参数和区域配置参数。全局配置参数用于设置整体的资源共享环境，对里面的每一个独立的共享资源都有效。区域配置参数则用于设置单独的共享资源，且仅对该资源有效。创建共享资源的方法很简单，只要将表12-2中的参数写入到Samba服务程序的主配置文件中，然后重启该服务即可。</p><p> 用于设置Samba服务程序的参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>[database]</td><td>共享名称为database</td></tr><tr><td>comment = Do not arbitrarily modify the database file</td><td>警告用户不要随意修改数据库</td></tr><tr><td>path = /home/database</td><td>共享目录为/home/database</td></tr><tr><td>public = no</td><td>关闭“所有人可见”</td></tr><tr><td>writable = yes</td><td>允许写入操作</td></tr></tbody></table><h3 id="Linux挂载共享"><a href="#Linux挂载共享" class="headerlink" title="Linux挂载共享"></a>Linux挂载共享</h3><p>上面的实验操作可能会让各位读者误以为Samba服务程序只是为了解决Linux系统和Windows系统的资源共享问题而设计的。其实，Samba服务程序还可以实现Linux系统之间的文件共享。请各位读者按照表12-5来设置Samba服务程序所在主机（即Samba共享服务器）和Linux客户端使用的IP地址，然后在客户端安装支持文件共享服务的软件包（cifs-utils）。</p><p> Samba共享服务器和Linux客户端各自使用的操作系统以及IP地址</p><table><thead><tr><th>主机名称</th><th>操作系统</th><th>IP地址</th></tr></thead><tbody><tr><td>Samba共享服务器</td><td>RHEL 7</td><td>192.168.10.10</td></tr><tr><td>Linux客户端</td><td>RHEL 7</td><td>192.168.10.20</td></tr><tr><td>Windows客户端</td><td>Windows 7</td><td>192.168.10.30</td></tr></tbody></table><h2 id="NFS网络文件系统"><a href="#NFS网络文件系统" class="headerlink" title="NFS网络文件系统"></a>NFS网络文件系统</h2><p>NFS（网络文件系统）服务可以将远程Linux系统上的文件共享资源挂载到本地主机的目录上，从而使得本地主机（Linux客户端）基于TCP/IP协议，像使用本地主机上的资源那样读写远程Linux系统上的共享文件。</p><p>yum install nfs-utils  安装nfs</p><p><strong>第1步</strong>：为了检验NFS服务配置的效果，我们需要使用两台Linux主机（一台充当NFS服务器，一台充当NFS客户端），并设置它们所使用的IP地址。</p><p>两台Linux主机所使用的操作系统以及IP地址</p><table><thead><tr><th>主机名称</th><th>操作系统</th><th>IP地址</th></tr></thead><tbody><tr><td>NFS服务端</td><td>RHEL 7</td><td>192.168.10.10</td></tr><tr><td>NFS客户端</td><td>RHEL 7</td><td>192.168.10.20</td></tr></tbody></table><p>另外，不要忘记清空NFS服务器上面iptables防火墙的默认策略，以免默认的防火墙策略禁止正常的NFS共享服务。</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# iptables -F[root@linuxprobe ~]# service iptables saveiptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ]</code></pre><p><strong>第2步</strong>：在NFS服务器上建立用于NFS文件共享的目录，并设置足够的权限确保其他人也有写入权限。</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# mkdir /nfsfile[root@linuxprobe ~]# chmod -Rf 777 /nfsfile[root@linuxprobe ~]# echo "welcome to linuxprobe.com" > /nfsfile/readme</code></pre><p><strong>第3步</strong>：NFS服务程序的配置文件为/etc/exports，默认情况下里面没有任何内容。我们可以按照“共享目录的路径 允许访问的NFS客户端（共享权限参数）”的格式，定义要共享的目录与相应的权限。</p><p>例如，如果想要把/nfsfile目录共享给192.168.10.0/24网段内的所有主机，让这些主机都拥有读写权限，在将数据写入到NFS服务器的硬盘中后才会结束操作，最大限度保证数据不丢失，以及把来访客户端root管理员映射为本地的匿名用户等，则可以按照下面命令中的格式，将下面的参数写到NFS服务程序的配置文件中。</p><p>  用于配置NFS服务程序配置文件的参数</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>ro</td><td>只读</td></tr><tr><td>rw</td><td>读写</td></tr><tr><td>root_squash</td><td>当NFS客户端以root管理员访问时，映射为NFS服务器的匿名用户</td></tr><tr><td>no_root_squash</td><td>当NFS客户端以root管理员访问时，映射为NFS服务器的root管理员</td></tr><tr><td>all_squash</td><td>无论NFS客户端使用什么账户访问，均映射为NFS服务器的匿名用户</td></tr><tr><td>sync</td><td>同时将数据写入到内存与硬盘中，保证不丢失数据</td></tr><tr><td>async</td><td>优先将数据保存到内存，然后再写入硬盘；这样效率更高，但可能会丢失数据</td></tr></tbody></table><p>NFS客户端地址与权限之间没有空格</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# vim /etc/exports/nfsfile 192.168.10.*(rw,sync,root_squash)</code></pre><p><strong>第4步</strong>：启动和启用NFS服务程序。由于在使用NFS服务进行文件共享之前，需要使用RPC（Remote Procedure Call，远程过程调用）服务将NFS服务器的IP地址和端口号等信息发送给客户端。因此，在启动NFS服务之前，还需要顺带重启并启用rpcbind服务程序，并将这两个服务一并加入开机启动项中。</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# systemctl restart rpcbind[root@linuxprobe ~]# systemctl enable rpcbind[root@linuxprobe ~]# systemctl start nfs-server[root@linuxprobe ~]# systemctl enable nfs-serverln -s '/usr/lib/systemd/system/nfs-server.service' '/etc/systemd/system/nfs.target.wants/nfs-server.service'</code></pre><p>NFS客户端的配置步骤也十分简单。先使用showmount命令（以及必要的参数，见表12-8）查询NFS服务器的远程共享信息，其输出格式为“共享的目录名称 允许使用客户端地址”。</p><p> showmount命令中可用的参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-e</td><td>显示NFS服务器的共享列表</td></tr><tr><td>-a</td><td>显示本机挂载的文件资源的情况NFS资源的情况</td></tr><tr><td>-v</td><td>显示版本号</td></tr></tbody></table><h2 id="AutoFs自动挂载服务"><a href="#AutoFs自动挂载服务" class="headerlink" title="AutoFs自动挂载服务"></a>AutoFs自动挂载服务</h2><p>无论是Samba服务还是NFS服务，都要把挂载信息写入到/etc/fstab中，这样远程共享资源就会自动随服务器开机而进行挂载。虽然这很方便，但是如果挂载的远程资源太多，则会给网络带宽和服务器的硬件资源带来很大负载。如果在资源挂载后长期不使用，也会造成服务器硬件资源的浪费。可能会有读者说，“可以在每次使用之前执行mount命令进行手动挂载”。这是一个不错的选择，但是每次都需要先挂载再使用，您不觉得麻烦吗？</p><p>autofs自动挂载服务可以帮我们解决这一问题。与mount命令不同，autofs服务程序是一种Linux系统守护进程，当检测到用户试图访问一个尚未挂载的文件系统时，将自动挂载该文件系统。换句话说，我们将挂载信息填入/etc/fstab文件后，系统在每次开机时都自动将其挂载，而autofs服务程序则是在用户需要使用该文件系统时才去动态挂载，从而节约了网络资源和服务器的硬件资源。</p><p>yum install autofs  安装autofs服务</p><h1 id="使用Bind提供域名解析服务"><a href="#使用Bind提供域名解析服务" class="headerlink" title="使用Bind提供域名解析服务"></a>使用Bind提供域名解析服务</h1><h2 id="DNS域名解析服务"><a href="#DNS域名解析服务" class="headerlink" title="DNS域名解析服务"></a>DNS域名解析服务</h2><p>相较于由数字构成的IP地址，域名更容易被理解和记忆，所以我们通常更习惯通过域名的方式来访问网络中的资源。但是，网络中的计算机之间只能基于IP地址来相互识别对方的身份，而且要想在互联网中传输数据，也必须基于外网的IP地址来完成。</p><p>为了降低用户访问网络资源的门槛，DNS（Domain Name System，域名系统）技术应运而生。这是一项用于管理和解析域名与IP地址对应关系的技术，简单来说，就是能够接受用户输入的域名或IP地址，然后自动查找与之匹配（或者说具有映射关系）的IP地址或域名，即将域名解析为IP地址（正向解析），或将IP地址解析为域名（反向解析）。这样一来，我们只需要在浏览器中输入域名就能打开想要访问的网站了。DNS域名解析技术的正向解析也是我们最常使用的一种工作模式。</p><p>当今世界的信息化程度越来越高，大数据、云计算、物联网、人工智能等新技术不断涌现，全球网民的数量据说也超过了35亿，而且每年还在以10%的速度迅速增长。这些因素导致互联网中的域名数量进一步激增，被访问的频率也进一步加大。假设全球网民每人每天只访问一个网站域名，而且只访问一次，也会产生35亿次的查询请求，如此庞大的请求数量肯定无法被某一台服务器全部处理掉。DNS技术作为互联网基础设施中重要的一环，为了为网民提供不间断、稳定且快速的域名查询服务，保证互联网的正常运转，提供了下面三种类型的服务器。</p><blockquote><p><strong>主服务器</strong>：在特定区域内具有唯一性，负责维护该区域内的域名与IP地址之间的对应关系。</p><p><strong>从服务器</strong>：从主服务器中获得域名与IP地址的对应关系并进行维护，以防主服务器宕机等情况。</p><p><strong>缓存服务器</strong>：通过向其他域名解析服务器查询获得域名与IP地址的对应关系，并将经常查询的域名信息保存到服务器本地，以此来提高重复查询时的效率。</p></blockquote><p> 13台根DNS服务器的具体信息</p><table><thead><tr><th>名称</th><th>管理单位</th><th>地理位置</th><th>IP地址</th></tr></thead><tbody><tr><td>A</td><td>INTERNIC.NET</td><td>美国-弗吉尼亚州</td><td>198.41.0.4</td></tr><tr><td>B</td><td>美国信息科学研究所</td><td>美国-加利弗尼亚州</td><td>128.9.0.107</td></tr><tr><td>C</td><td>PSINet公司</td><td>美国-弗吉尼亚州</td><td>192.33.4.12</td></tr><tr><td>D</td><td>马里兰大学</td><td>美国-马里兰州</td><td>128.8.10.90</td></tr><tr><td>E</td><td>美国航空航天管理局</td><td>美国加利弗尼亚州</td><td>192.203.230.10</td></tr><tr><td>F</td><td>因特网软件联盟</td><td>美国加利弗尼亚州</td><td>192.5.5.241</td></tr><tr><td>G</td><td>美国国防部网络信息中心</td><td>美国弗吉尼亚州</td><td>192.112.36.4</td></tr><tr><td>H</td><td>美国陆军研究所</td><td>美国-马里兰州</td><td>128.63.2.53</td></tr><tr><td>I</td><td>Autonomica公司</td><td>瑞典-斯德哥尔摩</td><td>192.36.148.17</td></tr><tr><td>J</td><td>VeriSign公司</td><td>美国-弗吉尼亚州</td><td>192.58.128.30</td></tr><tr><td>K</td><td>RIPE NCC</td><td>英国-伦敦</td><td>193.0.14.129</td></tr><tr><td>L</td><td>IANA</td><td>美国-弗吉尼亚州</td><td>199.7.83.42</td></tr><tr><td>M</td><td>WIDE Project</td><td>日本-东京</td><td>202.12.27.33</td></tr></tbody></table><h3 id="安装Bind服务程序"><a href="#安装Bind服务程序" class="headerlink" title="安装Bind服务程序"></a>安装Bind服务程序</h3><p>yum install bind-chroot</p><p>bind服务程序的配置并不简单，因为要想为用户提供健全的DNS查询服务，要在本地保存相关的域名数据库，而如果把所有域名和IP地址的对应关系都写入到某个配置文件中，估计要有上千万条的参数，这样既不利于程序的执行效率，也不方便日后的修改和维护。因此在bind服务程序中有下面这三个比较关键的文件。</p><blockquote><p>主配置文件（/etc/named.conf）：只有58行，而且在去除注释信息和空行之后，实际有效的参数仅有30行左右，这些参数用来定义bind服务程序的运行。</p><p>区域配置文件（/etc/named.rfc1912.zones）：用来保存域名和IP地址对应关系的所在位置。类似于图书的目录，对应着每个域和相应IP地址所在的具体位置，当需要查看或修改时，可根据这个位置找到相关文件。</p><p>数据配置文件目录（/var/named）：该目录用来保存域名和IP地址真实对应关系的数据配置文件。</p></blockquote><p>在Linux系统中，bind服务程序的名称为named。首先需要在/etc目录中找到该服务程序的主配置文件，然后把第11行和第17行的地址均修改为any，分别表示服务器上的所有IP地址均可提供DNS域名解析服务，以及允许所有人对本服务器发送DNS查询请求。这两个地方一定要修改准确。</p><pre class=" language-shell"><code class="language-shell"> [root@linuxprobe ~]# vim /etc/named.conf 1 // 2 // named.conf 3 // 4 // Provided by Red Hat bind package to configure the ISC BIND named(8) DNS 5 // server as a caching only nameserver (as a localhost DNS resolver only). 6 // 7 // See /usr/share/doc/bind*/sample/ for example named configuration files. 8 // 9  10 options &#123; 11 listen-on port 53 &#123; any; &#125;; 12 listen-on-v6 port 53 &#123; ::1; &#125;; 13 directory "/var/named"; 14 dump-file "/var/named/data/cache_dump.db"; 15 statistics-file "/var/named/data/named_stats.txt"; 16 memstatistics-file "/var/named/data/named_mem_stats.txt"; 17 allow-query &#123; any; &#125;; 18  19 /*  20 - If you are building an AUTHORITATIVE DNS server, do NOT enable re cursion. 1,1 Top 21 - If you are building a RECURSIVE (caching) DNS server, you need to enable  22 recursion.  23 - If your recursive DNS server has a public IP address, you MUST en able access  24 control to limit queries to your legitimate users. Failing to do so will 25 cause your server to become part of large scale DNS amplification  26 attacks. Implementing BCP38 within your network would greatly 27 reduce such attack surface  28 */ 29 recursion yes; 30  31 dnssec-enable yes; 32 dnssec-validation yes; 33 dnssec-lookaside auto; 34  35 /* Path to ISC DLV key */ 36 bindkeys-file "/etc/named.iscdlv.key"; 37  38 managed-keys-directory "/var/named/dynamic"; 39  40 pid-file "/run/named/named.pid"; 41 session-keyfile "/run/named/session.key"; 42 &#125;; 43  44 logging &#123; 45 channel default_debug &#123; 46 file "data/named.run"; 47 severity dynamic; 48 &#125;; 49 &#125;; 50  51 zone "." IN &#123; 52 type hint; 53 file "named.ca"; 54 &#125;; 55  56 include "/etc/named.rfc1912.zones"; 57 include "/etc/named.root.key"; 58 </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习 第十三天</title>
      <link href="linux-xue-xi-di-shi-san-tian.html"/>
      <url>linux-xue-xi-di-shi-san-tian.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用vsftpd服务传输文件"><a href="#使用vsftpd服务传输文件" class="headerlink" title="使用vsftpd服务传输文件"></a>使用vsftpd服务传输文件</h2><h3 id="文件传输协议"><a href="#文件传输协议" class="headerlink" title="文件传输协议"></a>文件传输协议</h3><p>FTP是一种在互联网中进行文件传输的协议，基于客户端/服务器模式，默认使用20、21号端口，其中端口20（数据端口）用于进行数据传输，端口21（命令端口）用于接受客户端发出的相关FTP命令与参数。FTP服务器普遍部署于内网中，具有容易搭建、方便管理的特点。而且有些FTP客户端工具还可以支持文件的多点下载以及断点续传技术，因此FTP服务得到了广大用户的青睐。</p><p>FTP服务器是按照FTP协议在互联网上提供文件存储和访问服务的主机，FTP客户端则是向服务器发送连接请求，以建立数据传输链路的主机。FTP协议有下面两种工作模式。</p><blockquote><p><strong>主动模式</strong>：FTP服务器主动向客户端发起连接请求。</p><p><strong>被动模式</strong>：FTP服务器等待客户端发起连接请求（FTP的默认工作模式）。</p></blockquote><p>vsftpd（very secure ftp daemon，非常安全的FTP守护进程）是一款运行在Linux操作系统上的FTP服务程序，不仅完全开源而且免费，此外，还具有很高的安全性、传输速度，以及支持虚拟用户验证等其他FTP服务程序不具备的特点。</p><p>yum install vsftpd    安装vsftpd服务</p><p>iptables防火墙管理工具默认禁止了FTP传输协议的端口号，因此在正式配置vsftpd服务程序之前，为了避免这些默认的防火墙策略“捣乱”，还需要清空iptables防火墙的默认策略，并把当前已经被清理的防火墙策略状态保存下来：</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# iptables -F[root@linuxprobe ~]# service iptables saveiptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ]</code></pre><p> vsftpd服务程序常用的参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>listen=[YES|NO]</td><td>是否以独立运行的方式监听服务</td></tr><tr><td>listen_address=IP地址</td><td>设置要监听的IP地址</td></tr><tr><td>listen_port=21</td><td>设置FTP服务的监听端口</td></tr><tr><td>download_enable＝[YES|NO]</td><td>是否允许下载文件</td></tr><tr><td>userlist_enable=[YES|NO] userlist_deny=[YES|NO]</td><td>设置用户列表为“允许”还是“禁止”操作</td></tr><tr><td>max_clients=0</td><td>最大客户端连接数，0为不限制</td></tr><tr><td>max_per_ip=0</td><td>同一IP地址的最大连接数，0为不限制</td></tr><tr><td>anonymous_enable=[YES|NO]</td><td>是否允许匿名用户访问</td></tr><tr><td>anon_upload_enable=[YES|NO]</td><td>是否允许匿名用户上传文件</td></tr><tr><td>anon_umask=022</td><td>匿名用户上传文件的umask值</td></tr><tr><td>anon_root=/var/ftp</td><td>匿名用户的FTP根目录</td></tr><tr><td>anon_mkdir_write_enable=[YES|NO]</td><td>是否允许匿名用户创建目录</td></tr><tr><td>anon_other_write_enable=[YES|NO]</td><td>是否开放匿名用户的其他写入权限（包括重命名、删除等操作权限）</td></tr><tr><td>anon_max_rate=0</td><td>匿名用户的最大传输速率（字节/秒），0为不限制</td></tr><tr><td>local_enable=[YES|NO]</td><td>是否允许本地用户登录FTP</td></tr><tr><td>local_umask=022</td><td>本地用户上传文件的umask值</td></tr><tr><td>local_root=/var/ftp</td><td>本地用户的FTP根目录</td></tr><tr><td>chroot_local_user=[YES|NO]</td><td>是否将用户权限禁锢在FTP目录，以确保安全</td></tr><tr><td>local_max_rate=0</td><td>本地用户最大传输速率（字节/秒），0为不限制</td></tr></tbody></table><h3 id="Vsftpd服务程序"><a href="#Vsftpd服务程序" class="headerlink" title="Vsftpd服务程序"></a>Vsftpd服务程序</h3><p>vsftpd作为更加安全的文件传输的服务程序，允许用户以三种认证模式登录到FTP服务器上。</p><p><strong>匿名开放模式</strong>：是一种最不安全的认证模式，任何人都可以无需密码验证而直接登录到FTP服务器。</p><p><strong>本地用户模式</strong>：是通过Linux系统本地的账户密码信息进行认证的模式，相较于匿名开放模式更安全，而且配置起来也很简单。但是如果被黑客破解了账户的信息，就可以畅通无阻地登录FTP服务器，从而完全控制整台服务器。</p><p><strong>虚拟用户模式</strong>：是这三种模式中最安全的一种认证模式，它需要为FTP服务单独建立用户数据库文件，虚拟出用来进行口令验证的账户信息，而这些账户信息在服务器系统中实际上是不存在的，仅供FTP服务程序进行认证使用。这样，即使黑客破解了账户信息也无法登录服务器，从而有效降低了破坏范围和影响。</p><p>ftp是Linux系统中以命令行界面的方式来管理FTP传输服务的客户端工具。我们首先手动安装这个ftp客户端工具，以便在后续实验中查看结果。</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# yum install ftpLoaded plugins: langpacks, product-id, subscription-manager………………省略部分输出信息………………Installing: ftp x86_64 0.17-66.el7 rhel 61 kTransaction Summary================================================================================Install 1 PackageTotal download size: 61 kInstalled size: 96 kIs this ok [y/d/N]: yDownloading packages:Running transaction checkRunning transaction testTransaction test succeededRunning transaction Installing : ftp-0.17-66.el7.x86_64 1/1  Verifying : ftp-0.17-66.el7.x86_64 1/1Installed: ftp.x86_64 0:0.17-66.el7Complete!</code></pre><h3 id="匿名访问模式"><a href="#匿名访问模式" class="headerlink" title="匿名访问模式"></a>匿名访问模式</h3><p>在vsftpd服务程序中，匿名开放模式是最不安全的一种认证模式。任何人都可以无需密码验证而直接登录到FTP服务器。这种模式一般用来访问不重要的公开文件（在生产环境中尽量不要存放重要文件）。</p><p>可以向匿名用户开放的权限参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>anonymous_enable=YES</td><td>允许匿名访问模式</td></tr><tr><td>anon_umask=022</td><td>匿名用户上传文件的umask值</td></tr><tr><td>anon_upload_enable=YES</td><td>允许匿名用户上传文件</td></tr><tr><td>anon_mkdir_write_enable=YES</td><td>允许匿名用户创建目录</td></tr><tr><td>anon_other_write_enable=YES</td><td>允许匿名用户修改目录名称或删除目录</td></tr></tbody></table><h3 id="本地用户模式"><a href="#本地用户模式" class="headerlink" title="本地用户模式"></a>本地用户模式</h3><p>相较于匿名开放模式，本地用户模式要更安全，而且配置起来也很简单。</p><p> 本地用户模式使用的权限参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>anonymous_enable=NO</td><td>禁止匿名访问模式</td></tr><tr><td>local_enable=YES</td><td>允许本地用户模式</td></tr><tr><td>write_enable=YES</td><td>设置可写权限</td></tr><tr><td>local_umask=022</td><td>本地用户模式创建文件的umask值</td></tr><tr><td>userlist_deny=YES</td><td>启用“禁止用户名单”，名单文件为ftpusers和user_list</td></tr><tr><td>userlist_enable=YES</td><td>开启用户作用名单文件功能</td></tr></tbody></table><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# vim /etc/vsftpd/vsftpd.conf1 anonymous_enable=NO2 local_enable=YES3 write_enable=YES4 local_umask=0225 dirmessage_enable=YES6 xferlog_enable=YES7 connect_from_port_20=YES8 xferlog_std_format=YES9 listen=NO10 listen_ipv6=YES11 pam_service_name=vsftpd12 userlist_enable=YES13 tcp_wrappers=YES</code></pre><h3 id="虚拟用户模式"><a href="#虚拟用户模式" class="headerlink" title="虚拟用户模式"></a>虚拟用户模式</h3><p>虚拟用户模式是这三种模式中最安全的一种认证模式，当然，因为安全性较之于前面两种模式有了提升，所以配置流程也会稍微复杂一些。</p><p><strong>第1步</strong>：创建用于进行FTP认证的用户数据库文件，其中奇数行为账户名，偶数行为密码。例如，我们分别创建出zhangsan和lisi两个用户，密码均为redhat：</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# cd /etc/vsftpd/[root@linuxprobe vsftpd]# vim vuser.listzhangsanredhatlisiredhat</code></pre><p>但是，明文信息既不安全，也不符合让vsftpd服务程序直接加载的格式，因此需要使用db_load命令用哈希（hash）算法将原始的明文信息文件转换成数据库文件，并且降低数据库文件的权限（避免其他人看到数据库文件的内容），然后再把原始的明文信息文件删除。</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe vsftpd]# db_load -T -t hash -f vuser.list vuser.db[root@linuxprobe vsftpd]# file vuser.dbvuser.db: Berkeley DB (Hash, version 9, native byte-order)[root@linuxprobe vsftpd]# chmod 600 vuser.db[root@linuxprobe vsftpd]# rm -f vuser.list</code></pre><p><strong>第2步</strong>：创建vsftpd服务程序用于存储文件的根目录以及虚拟用户映射的系统本地用户。FTP服务用于存储文件的根目录指的是，当虚拟用户登录后所访问的默认位置。</p><p>由于Linux系统中的每一个文件都有所有者、所属组属性，例如使用虚拟账户“张三”新建了一个文件，但是系统中找不到账户“张三”，就会导致这个文件的权限出现错误。为此，需要再创建一个可以映射到虚拟用户的系统本地用户。简单来说，就是让虚拟用户默认登录到与之有映射关系的这个系统本地用户的家目录中，虚拟用户创建的文件的属性也都归属于这个系统本地用户，从而避免Linux系统无法处理虚拟用户所创建文件的属性权限。</p><p>为了方便管理FTP服务器上的数据，可以把这个系统本地用户的家目录设置为/var目录（该目录用来存放经常发生改变的数据）。并且为了安全起见，我们将这个系统本地用户设置为不允许登录FTP服务器，这不会影响虚拟用户登录，而且还可以避免黑客通过这个系统本地用户进行登录。</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# useradd -d /var/ftproot -s /sbin/nologin virtual[root@linuxprobe ~]# ls -ld /var/ftproot/drwx------. 3 virtual virtual 74 Jul 14 17:50 /var/ftproot/[root@linuxprobe ~]# chmod -Rf 755 /var/ftproot/</code></pre><p><strong>第3步</strong>：建立用于支持虚拟用户的PAM文件。</p><p>PAM（可插拔认证模块）是一种认证机制，通过一些动态链接库和统一的API把系统提供的服务与认证方式分开，使得系统管理员可以根据需求灵活调整服务程序的不同认证方式。要想把PAM功能和作用完全讲透，至少要一个章节的篇幅才可以（对该主题感兴趣的读者敬请关注本书的进阶篇，里面会详细讲解PAM）。</p><p>通俗来讲，PAM是一组安全机制的模块，系统管理员可以用来轻易地调整服务程序的认证方式，而不必对应用程序进行任何修改。PAM采取了分层设计（应用程序层、应用接口层、鉴别模块层）的思想</p><p><img src="https://img.sunjingdong.com/Frlzfy5X_fGbADq-OzsAnfw-3mZP"></p><p>新建一个用于虚拟用户认证的PAM文件vsftpd.vu，其中PAM文件内的“db=”参数为使用db_load命令生成的账户密码数据库文件的路径，但不用写数据库文件的后缀：</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# vim /etc/pam.d/vsftpd.vuauth       required     pam_userdb.so db=/etc/vsftpd/vuseraccount    required     pam_userdb.so db=/etc/vsftpd/vuser</code></pre><p><strong>第4步</strong>：在vsftpd服务程序的主配置文件中通过pam_service_name参数将PAM认证文件的名称修改为vsftpd.vu，PAM作为应用程序层与鉴别模块层的连接纽带，可以让应用程序根据需求灵活地在自身插入所需的鉴别功能模块。当应用程序需要PAM认证时，则需要在应用程序中定义负责认证的PAM配置文件，实现所需的认证功能。</p><p> 利用PAM文件进行认证时使用的参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>anonymous_enable=NO</td><td>禁止匿名开放模式</td></tr><tr><td>local_enable=YES</td><td>允许本地用户模式</td></tr><tr><td>guest_enable=YES</td><td>开启虚拟用户模式</td></tr><tr><td>guest_username=virtual</td><td>指定虚拟用户账户</td></tr><tr><td>pam_service_name=vsftpd.vu</td><td>指定PAM文件</td></tr><tr><td>allow_writeable_chroot=YES</td><td>允许对禁锢的FTP根目录执行写入操作，而且不拒绝用户的登录请求</td></tr></tbody></table><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# vim /etc/vsftpd/vsftpd.conf1 anonymous_enable=NO2 local_enable=YES3 guest_enable=YES4 guest_username=virtual5 allow_writeable_chroot=YES6 write_enable=YES7 local_umask=0228 dirmessage_enable=YES9 xferlog_enable=YES10 connect_from_port_20=YES11 xferlog_std_format=YES12 listen=NO13 listen_ipv6=YES14 pam_service_name=vsftpd.vu15 userlist_enable=YES16 tcp_wrappers=YES</code></pre><p><strong>第5步</strong>：为虚拟用户设置不同的权限。虽然账户zhangsan和lisi都是用于vsftpd服务程序认证的虚拟账户，但是我们依然想对这两人进行区别对待。比如，允许张三上传、创建、修改、查看、删除文件，只允许李四查看文件。这可以通过vsftpd服务程序来实现。只需新建一个目录，在里面分别创建两个以zhangsan和lisi命名的文件，其中在名为zhangsan的文件中写入允许的相关权限（使用匿名用户的参数）：</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# mkdir /etc/vsftpd/vusers_dir/[root@linuxprobe ~]# cd /etc/vsftpd/vusers_dir/[root@linuxprobe vusers_dir]# touch lisi[root@linuxprobe vusers_dir]# vim zhangsananon_upload_enable=YESanon_mkdir_write_enable=YESanon_other_write_enable=YES</code></pre><p>然后再次修改vsftpd主配置文件，通过添加user_config_dir参数来定义这两个虚拟用户不同权限的配置文件所存放的路径。为了让修改后的参数立即生效，需要重启vsftpd服务程序并将该服务添加到开机启动项中：</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# vim /etc/vsftpd/vsftpd.confanonymous_enable=NOlocal_enable=YESguest_enable=YESguest_username=virtualallow_writeable_chroot=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YESpam_service_name=vsftpd.vuuserlist_enable=YEStcp_wrappers=YESuser_config_dir=/etc/vsftpd/vusers_dir[root@linuxprobe ~]# systemctl restart vsftpd[root@linuxprobe ~]# systemctl enable vsftpd ln -s '/usr/lib/systemd/system/vsftpd.service' '/etc/systemd/system/multi-user.target.wants/vsftpd.service</code></pre><p><strong>第6步</strong>：设置SELinux域允许策略，然后使用虚拟用户模式登录FTP服务器。相信大家可以猜到，SELinux会继续来捣乱。所以，先按照前面实验中的步骤开启SELinux域的允许策略，以免再次出现操作失败的情况：</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# getsebool -a | grep ftpftp_home_dir –> offftpd_anon_write –> offftpd_connect_all_unreserved –> offftpd_connect_db –> offftpd_full_access –> offftpd_use_cifs –> offftpd_use_fusefs –> offftpd_use_nfs –> offftpd_use_passive_mode –> offhttpd_can_connect_ftp –> offhttpd_enable_ftp_server –> offsftpd_anon_write –> offsftpd_enable_homedirs –> offsftpd_full_access –> offsftpd_write_ssh_home –> offtftp_anon_write –> offtftp_home_dir –> off[root@linuxprobe ~]# setsebool -P ftpd_full_access=on</code></pre><p>此时，不但可以使用虚拟用户模式成功登录到FTP服务器，还可以分别使用账户zhangsan和lisi来检验他们的权限。当然，读者在生产环境中一定要根据真实需求来灵活配置参数，不要照搬这里的实验操作。</p><pre class=" language-shell"><code class="language-shell">[root@linuxprobe ~]# ftp 192.168.10.10Connected to 192.168.10.10 (192.168.10.10).220 (vsFTPd 3.0.2)Name (192.168.10.10:root): lisi331 Please specify the password.Password:此处输入虚拟用户的密码230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp> mkdir files550 Permission denied.ftp> exit221 Goodbye.[root@linuxprobe ~]# ftp 192.168.10.10Connected to 192.168.10.10 (192.168.10.10).220 (vsFTPd 3.0.2)Name (192.168.10.10:root): zhangsan331 Please specify the password.Password:此处输入虚拟用户的密码230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp> mkdir files257 "/files" createdftp> rename files database350 Ready for RNTO.250 Rename successful.ftp> rmdir database250 Remove directory operation successful.ftp> exit221 Goodbye.</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习 第十二天</title>
      <link href="linux-xue-xi-di-shi-er-tian.html"/>
      <url>linux-xue-xi-di-shi-er-tian.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用Apache服务部署静态网站"><a href="#使用Apache服务部署静态网站" class="headerlink" title="使用Apache服务部署静态网站"></a>使用Apache服务部署静态网站</h1><h2 id="部署Apache"><a href="#部署Apache" class="headerlink" title="部署Apache"></a>部署Apache</h2><ol><li>把光盘设备中的系统镜像挂载到/media/cdrom目录</li></ol><pre spellcheck="false" class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" lang="shell" cid="n6" mdtype="fences"> <span role="presentation">[root@linuxprobe ~]<span class="cm-comment"># mkdir -p /media/cdrom</span></span><br> <span role="presentation">[root@linuxprobe ~]<span class="cm-comment"># mount /dev/cdrom /media/cdrom</span></span><br> <span role="presentation">mount: /dev/sr0 is write-protected, mounting read-only</span></pre><ol start="2"><li>使用Vim文本编辑器创建Yum仓库的配置文件</li></ol><pre spellcheck="false" class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" lang="shell" cid="n10" mdtype="fences"> <span role="presentation">[root@linuxprobe ~]<span class="cm-comment"># vim /etc/yum.repos.d/rhel7.repo</span></span><br> <span role="presentation">[rhel7]</span><br> <span role="presentation"><span class="cm-def">name</span><span class="cm-operator">=</span>rhel7</span><br> <span role="presentation"><span class="cm-def">baseurl</span><span class="cm-operator">=</span>file:///media/cdrom</span><br> <span role="presentation"><span class="cm-def">enabled</span><span class="cm-operator">=</span><span class="cm-number">1</span></span><br> <span role="presentation"><span class="cm-def">gpgcheck</span><span class="cm-operator">=</span><span class="cm-number">0</span></span></pre><ol start="3"><li>安装Apache服务</li></ol><pre spellcheck="false" class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" lang="shell" cid="n14" mdtype="fences"> <span role="presentation">[root@linuxprobe ~]<span class="cm-comment"># yum install httpd</span></span><br> <span role="presentation">Loaded plugins: langpacks, product-id, subscription-manager</span><br> <span role="presentation">………………省略部分输出信息………………</span><br> <span role="presentation">Dependencies Resolved</span><br> <span role="presentation"><span class="cm-operator">================================================================================</span></span><br> <span role="presentation"> Package Arch Version Repository Size</span><br> <span role="presentation"><span class="cm-operator">================================================================================</span></span><br> <span role="presentation">Installing:</span><br> <span role="presentation"> httpd x86_64 <span class="cm-number">2</span>.4.6-17.el7 rhel <span class="cm-number">1</span>.2 M</span><br> <span role="presentation">Installing <span class="cm-keyword">for</span> dependencies:</span><br> <span role="presentation"> apr x86_64 <span class="cm-number">1</span>.4.8-3.el7 rhel <span class="cm-number">103</span> k</span><br> <span role="presentation"> apr-util x86_64 <span class="cm-number">1</span>.5.2-6.el7 rhel <span class="cm-number">92</span> k</span><br> <span role="presentation"> httpd-tools x86_64 <span class="cm-number">2</span>.4.6-17.el7 rhel <span class="cm-number">77</span> k</span><br> <span role="presentation"> mailcap noarch <span class="cm-number">2</span>.1.41-2.el7 rhel <span class="cm-number">31</span> k</span><br> <span role="presentation">Transaction Summary</span><br> <span role="presentation"><span class="cm-operator">================================================================================</span></span><br> <span role="presentation">Install <span class="cm-number">1</span> Package (<span class="cm-operator">+</span><span class="cm-number">4</span> Dependent packages)</span><br> <span role="presentation">Total download size: <span class="cm-number">1</span>.5 M</span><br> <span role="presentation">Installed size: <span class="cm-number">4</span>.3 M</span><br> <span role="presentation">Is this ok [y/d/N]: y</span><br> <span role="presentation">Downloading packages:</span><br> <span role="presentation"><span class="cm-attribute">--------------------------------------------------------------------------------</span></span><br> <span role="presentation">………………省略部分输出信息………………</span><br> <span role="presentation">Complete!</span></pre><ol start="4"><li>启用httpd服务程序并将其加入到开机启动项中，使其能够随系统开机而运行，从而持续为用户提供Web服务</li></ol><pre spellcheck="false" class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" lang="shell" cid="n18" mdtype="fences"> <span role="presentation">[root@linuxprobe ~]<span class="cm-comment"># systemctl start httpd</span></span><br> <span role="presentation">[root@linuxprobe ~]<span class="cm-comment"># systemctl enable httpd</span></span><br> <span role="presentation"><span class="cm-builtin">ln</span> <span class="cm-attribute">-s</span> <span class="cm-string">'/usr/lib/systemd/system/httpd.service'</span> <span class="cm-string">'/etc/systemd/system/multi-user.target.wants/httpd.service'</span></span></pre><h2 id="配置服务文件参数"><a href="#配置服务文件参数" class="headerlink" title="配置服务文件参数"></a>配置服务文件参数</h2><h3 id="Linux系统中的配置文件"><a href="#Linux系统中的配置文件" class="headerlink" title="Linux系统中的配置文件"></a>Linux系统中的配置文件</h3><table><thead><tr><th>服务目录</th><th>/etc/httpd</th></tr></thead><tbody><tr><td>主配置文件</td><td>/etc/httpd/conf/httpd.conf</td></tr><tr><td>网站数据目录</td><td>/var/www/html</td></tr><tr><td>访问日志</td><td>/var/log/httpd/access_log</td></tr><tr><td>错误日志</td><td>/var/log/httpd/error_log</td></tr></tbody></table><p>在httpd服务程序的主配置文件中，存在三种类型的信息：注释行信息、全局配置、区域配置</p><p><img src="https://img.sunjingdong.com/Fhl9W0EWN5LovxdmZmqMN0TrUuos"></p><h3 id="配置httpd服务程序时最常用的参数以及用途描述"><a href="#配置httpd服务程序时最常用的参数以及用途描述" class="headerlink" title="配置httpd服务程序时最常用的参数以及用途描述"></a>配置httpd服务程序时最常用的参数以及用途描述</h3><table><thead><tr><th>ServerRoot</th><th>服务目录</th></tr></thead><tbody><tr><td>ServerAdmin</td><td>管理员邮箱</td></tr><tr><td>User</td><td>运行服务的用户</td></tr><tr><td>Group</td><td>运行服务的用户组</td></tr><tr><td>ServerName</td><td>网站服务器的域名</td></tr><tr><td>DocumentRoot</td><td>网站数据目录</td></tr><tr><td>Listen</td><td>监听的IP地址与端口号</td></tr><tr><td>DirectoryIndex</td><td>默认的索引页页面</td></tr><tr><td>ErrorLog</td><td>错误日志文件</td></tr><tr><td>CustomLog</td><td>访问日志文件</td></tr><tr><td>Timeout</td><td>网页超时时间，默认为300秒</td></tr></tbody></table><h2 id="SELinux安全子系统"><a href="#SELinux安全子系统" class="headerlink" title="SELinux安全子系统"></a>SELinux安全子系统</h2><p>SELinux（Security-Enhanced Linux）是美国国家安全局在Linux开源社区的帮助下开发的一个强制访问控制（MAC，Mandatory Access Control）的安全子系统。RHEL 7系统使用SELinux技术的目的是为了让各个服务进程都受到约束，使其仅获取到本应获取的资源。</p><p>SELinux服务有三种配置模式，具体如下。</p><blockquote><p>enforcing：强制启用安全策略模式，将拦截服务的不合法请求。</p><p>permissive：遇到服务越权访问时，只发出警告而不强制拦截。</p><p>disabled：对于越权的行为不警告也不拦截。</p></blockquote><h4 id="semanage命令"><a href="#semanage命令" class="headerlink" title="semanage命令"></a><strong>semanage命令</strong></h4><p>semanage命令用于管理SELinux的策略，格式为“semanage [选项] [文件]”。</p><p>SELinux服务极大地提升了Linux系统的安全性，将用户权限牢牢地锁在笼子里。semanage命令不仅能够像传统chcon命令那样—设置文件、目录的策略，还可以管理网络端口、消息接口（这些新特性将在本章后文中涵盖）。使用semanage命令时，经常用到的几个参数及其功能如下所示：</p><blockquote><p>-l参数用于查询；</p><p>-a参数用于添加；</p><p>-m参数用于修改；</p><p>-d参数用于删除。</p></blockquote><p>例如，可以向新的网站数据目录中新添加一条SELinux安全上下文，让这个目录以及里面的所有文件能够被httpd服务程序所访问到：</p><pre spellcheck="false" class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" lang="shell" cid="n90" mdtype="fences"> <span role="presentation">[root@linuxprobe ~]<span class="cm-comment"># semanage fcontext -a -t httpd_sys_content_t /home/wwwroot</span></span><br> <span role="presentation">[root@linuxprobe ~]<span class="cm-comment"># semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/*</span></span></pre><p>注意，执行上述设置之后，还无法立即访问网站，还需要使用restorecon命令将设置好的SELinux安全上下文立即生效。在使用restorecon命令时，可以加上-Rv参数对指定的目录进行递归操作，以及显示SELinux安全上下文的修改过程。最后，再次刷新页面，就可以正常看到网页内容了。</p><h2 id="个人用户主页功能"><a href="#个人用户主页功能" class="headerlink" title="个人用户主页功能"></a>个人用户主页功能</h2><p>如果想在系统中为每位用户建立一个独立的网站，通常的方法是基于虚拟网站主机功能来部署多个网站。但这个工作会让管理员苦不堪言（尤其是用户数量很庞大时），而且在用户自行管理网站时，还会碰到各种权限限制，需要为此做很多额外的工作。其实，httpd服务程序提供的个人用户主页功能完全可以胜任这个工作。该功能可以让系统内所有的用户在自己的家目录中管理个人的网站，而且访问起来也非常容易。</p><h2 id="虚拟网站主机功能"><a href="#虚拟网站主机功能" class="headerlink" title="虚拟网站主机功能"></a>虚拟网站主机功能</h2><h3 id="基于IP"><a href="#基于IP" class="headerlink" title="基于IP"></a>基于IP</h3><p>如果一台服务器有多个IP地址，而且每个IP地址与服务器上部署的每个网站一一对应，这样当用户请求访问不同的IP地址时，会访问到不同网站的页面资源。</p><h3 id="基于主机域名"><a href="#基于主机域名" class="headerlink" title="基于主机域名"></a>基于主机域名</h3><p>当服务器无法为每个网站都分配一个独立IP地址的时候，可以尝试让Apache自动识别用户请求的域名，从而根据不同的域名请求来传输不同的内容。</p><h3 id="基于端口号"><a href="#基于端口号" class="headerlink" title="基于端口号"></a>基于端口号</h3><p>基于端口号的虚拟主机功能可以让用户通过指定的端口号来访问服务器上的网站资源。在使用Apache配置虚拟网站主机功能时，基于端口号的配置方式是最复杂的。因此我们不仅要考虑httpd服务程序的配置因素，还需要考虑到SELinux服务对新开设端口的监控。一般来说，使用80、443、8080等端口号来提供网站访问服务是比较合理的，如果使用其他端口号则会受到SELinux服务的限制。</p><h2 id="Apache的访问控制"><a href="#Apache的访问控制" class="headerlink" title="Apache的访问控制"></a>Apache的访问控制</h2><p>Apache可以基于源主机名、源IP地址或源主机上的浏览器特征等信息对网站上的资源进行访问控制。它通过Allow指令允许某个主机访问服务器上的网站资源，通过Deny指令实现禁止访问。在允许或禁止访问网站资源时，还会用到Order指令，这个指令用来定义Allow或Deny指令起作用的顺序，其匹配原则是按照顺序进行匹配，若匹配成功则执行后面的默认指令。比如“Order Allow, Deny”表示先将源主机与允许规则进行匹配，若匹配成功则允许访问请求，反之则拒绝访问请求。<br><img src="https://img.sunjingdong.com/FsoAxpQ2wuKLW3g-h8VcnD3e1jgZ"><br><img src="https://img.sunjingdong.com/FoQclaWXHagsb7j1QLOrps3B5SO6"><br><img src="https://img.sunjingdong.com/Fllfr6F56-gCNjOgGa2Uh3y3lz1e"><br><img src="https://img.sunjingdong.com/FpJHMEl-D84PkIhclffOaZLgKyL7"><br><img src="https://img.sunjingdong.com/Fn4xIyyPWqCdeQGeSFAafusNnW6-"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习 第十一天</title>
      <link href="linux-xue-xi-di-shi-yi-tian.html"/>
      <url>linux-xue-xi-di-shi-yi-tian.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用ssh服务管理远程主机"><a href="#使用ssh服务管理远程主机" class="headerlink" title="使用ssh服务管理远程主机"></a>使用ssh服务管理远程主机</h2><h3 id="配置网卡"><a href="#配置网卡" class="headerlink" title="配置网卡"></a>配置网卡</h3><h4 id="4种配置方式"><a href="#4种配置方式" class="headerlink" title="4种配置方式"></a>4种配置方式</h4><h3 id="创建网络会话"><a href="#创建网络会话" class="headerlink" title="创建网络会话"></a>创建网络会话</h3><p>RHEL和CentOS系统默认使用NetworkManager来提供网络服务，这是一种动态管理网络配置的守护进程，能够让网络设备保持连接状态。可以使用nmcli命令来管理Network Manager服务。nmcli是一款基于命令行的网络配置工具，功能丰富，参数众多。它可以轻松地查看网络信息或网络状态<br><img src="https://img.sunjingdong.com/FkLb4CGZ0EG5dRXXFC8oBEAhwQ-q"></p><p>RHEL7系统支持网络会话功能，允许用户在多个配置文件中快速切换（非常类似于firewalld防火墙服务中的区域技术）。如果我们在公司网络中使用笔记本电脑时需要手动指定网络的IP地址，而回到家中则是使用DHCP自动分配IP地址。这就需要麻烦地频繁修改IP地址，但是使用了网络会话功能后一切就简单多了—只需在不同的使用环境中激活相应的网络会话，就可以实现网络配置信息的自动切换了。</p><blockquote><p>使用nmcli命令按照”connection add con-name type ifname”的格式来创建网络会话</p><p>使用con-name参数指定公司所使用的网络会话名称，然后用ifname参数指定本机的网卡名称</p><p>使用con-namme参数指定家庭所使用的网络会话名称</p><p>使用nmcli命令查看创建的所有网络会话</p><p>使用nmcli命令配置过的网络会话是永久生效的</p></blockquote><h3 id="远程控制服务"><a href="#远程控制服务" class="headerlink" title="远程控制服务"></a>远程控制服务</h3><h4 id="配置sshd服务"><a href="#配置sshd服务" class="headerlink" title="配置sshd服务"></a>配置sshd服务</h4><p>SSH（Secure Shell）是一种能够以安全的方式提供远程登录的协议，也是目前远程管理Linux系统的首选方式。在此之前，一般使用FTP或Telnet来进行远程登录。但是因为它们以明文的形式在网络中传输账户密码和数据信息，因此很不安全，很容易受到黑客发起的中间人攻击，这轻则篡改传输的数据信息，重则直接抓取服务器的账户密码。</p><p>想要使用SSH协议来远程管理Linux系统，则需要部署配置sshd服务程序。sshd是基于SSH协议开发的一款远程管理服务程序，不仅使用起来方便快捷，而且能够提供两种安全验证的方法：</p><blockquote><p>基于口令的验证—用账户和密码来验证登录；</p><p>基于密钥的验证—需要在本地生成密钥对，然后把密钥对中的公钥上传至服务器，并与服务器中的公钥进行比较；该方式相较来说更安全。</p></blockquote><h5 id="常用参数以及作用"><a href="#常用参数以及作用" class="headerlink" title="常用参数以及作用"></a>常用参数以及作用</h5><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>Port 22</td><td>默认的sshd服务端口</td></tr><tr><td>ListenAddress 0.0.0.0</td><td>设定sshd服务器监听的IP地址</td></tr><tr><td>Protocol 2</td><td>SSH协议的版本号</td></tr><tr><td>HostKey /tc/ssh/ssh_host_key</td><td>SSH协议版本为1时，DES私钥存放的位置</td></tr><tr><td>HostKey /etc/ssh/ssh_host_rsa_key</td><td>SSH协议版本为2时，RSA私钥存放的位置</td></tr><tr><td>HostKey /etc/ssh/ssh_host_dsa_key</td><td>SSH协议版本为2时，DSA私钥存放的位置</td></tr><tr><td>PermitRootLogin yes</td><td>设定是否允许root管理员直接登录</td></tr><tr><td>StrictModes yes</td><td>当远程用户的私钥改变时直接拒绝连接</td></tr><tr><td>MaxAuthTries 6</td><td>最大密码尝试次数</td></tr><tr><td>MaxSessions 10</td><td>最大终端数</td></tr><tr><td>PasswordAuthentication yes</td><td>是否允许密码验证</td></tr><tr><td>PermitEmptyPasswords no</td><td>是否允许空密码登录（很不安全）</td></tr></tbody></table><h4 id="安全密钥验证"><a href="#安全密钥验证" class="headerlink" title="安全密钥验证"></a>安全密钥验证</h4><h5 id="1-在客户端主机中生成“密钥对”"><a href="#1-在客户端主机中生成“密钥对”" class="headerlink" title="1.在客户端主机中生成“密钥对”"></a>1.在客户端主机中生成“密钥对”</h5><pre><code>[root@linuxprobe ~]# ssh-keygen  Generating public/private rsa key pair.  Enter file in which to save the key (/root/.ssh/id_rsa):按回车键或设置密钥的存储路径  Created directory &#39;/root/.ssh&#39;.  Enter passphrase (empty for no passphrase):直接按回车键或设置密钥的密码  Enter same passphrase again:再次按回车键或设置密钥的密码  Your identification has been saved in /root/.ssh/id_rsa.  Your public key has been saved in /root/.ssh/id_rsa.pub.  Your identification has been saved in /root/.ssh/id_rsa.  Your public key has been saved in /root/.ssh/id_rsa.pub.  The key fingerprint is:  40:32:48:18:e4:ac:c0:c3:c1:ba:7c:6c:3a:a8:b5:22 root@linuxprobe.com  The key&#39;s randomart image is:  +--[ RSA 2048]----+  |+*..o .          |  |*.o  +           |  |o*    .          |  |+ .    .         |  |o..     S        |  |.. +             |  |. =              |  |E+ .             |  |+.o             |  +-----------------+</code></pre><h5 id="2-把客户端主机中生成的公钥文件传送至远程主机"><a href="#2-把客户端主机中生成的公钥文件传送至远程主机" class="headerlink" title="2.把客户端主机中生成的公钥文件传送至远程主机"></a>2.把客户端主机中生成的公钥文件传送至远程主机</h5><pre><code> [root@linuxprobe ~]# ssh-copy-id 192.168.10.10   The authenticity of host &#39;192.168.10.20 (192.168.10.10)&#39; can&#39;t be established.   ECDSA key fingerprint is 4f:a7:91:9e:8d:6f:b9:48:02:32:61:95:48:ed:1e:3f.   Are you sure you want to continue connecting (yes/no)? yes   /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed   /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys   root@192.168.10.10&#39;s password:此处输入远程服务器密码   Number of key(s) added: 1   Now try logging into the machine, with: &quot;ssh &#39;192.168.10.10&#39;&quot;   and check to make sure that only the key(s) you wanted were added.</code></pre><h5 id="3-对服务器进行设置，使其只允许密钥验证，拒绝传统的口令验证方式。记得在修改配置文件后保存并重启sshd服务程序"><a href="#3-对服务器进行设置，使其只允许密钥验证，拒绝传统的口令验证方式。记得在修改配置文件后保存并重启sshd服务程序" class="headerlink" title="3.对服务器进行设置，使其只允许密钥验证，拒绝传统的口令验证方式。记得在修改配置文件后保存并重启sshd服务程序"></a>3.对服务器进行设置，使其只允许密钥验证，拒绝传统的口令验证方式。记得在修改配置文件后保存并重启sshd服务程序</h5><pre><code> [root@linuxprobe ~]# vim /etc/ssh/sshd_config     ………………省略部分输出信息………………    74     75 # To disable tunneled clear text passwords, change to no here!    76 #PasswordAuthentication yes    77 #PermitEmptyPasswords no    78 PasswordAuthentication no    79     ………………省略部分输出信息………………   [root@linuxprobe ~]# systemctl restart sshd</code></pre><h5 id="4-在客户端尝试登录到服务器，此时无须输入密码也可成功登录"><a href="#4-在客户端尝试登录到服务器，此时无须输入密码也可成功登录" class="headerlink" title="4.在客户端尝试登录到服务器，此时无须输入密码也可成功登录"></a>4.在客户端尝试登录到服务器，此时无须输入密码也可成功登录</h5><pre><code> [root@linuxprobe ~]# ssh 192.168.10.10   Last login: Mon May 23 11:24:56 2020</code></pre><h3 id="远程传输命令"><a href="#远程传输命令" class="headerlink" title="远程传输命令"></a>远程传输命令</h3><h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><p>scp（secure copy）是一个基于SSH协议在网络之间进行安全传输的命令，其格式为“scp [参数] 本地文件 远程帐户@远程IP地址:远程目录”</p><p>scp与cp命令不同，cp命令只能在本地硬盘中进行文件复制，而scp不仅能够通过网络传送数据，而且所有的数据都将进行加密处理。例如，如果想把一些文件通过网络从一台主机传递到其他主机，这两台主机又恰巧是Linux系统，这时使用scp命令就可以轻松完成文件的传递了。</p><p>scp命令中可用的参数及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-v</td><td>显示详细的连接进度</td></tr><tr><td>-P</td><td>指定远程主机的sshd端口号</td></tr><tr><td>-r</td><td>用于传送文件夹</td></tr><tr><td>-6</td><td>使用IPv6协议</td></tr></tbody></table><p>在使用scp命令把文件从本地复制到远程主机时，首先需要以绝对路径的形式写清本地文件的存放位置。如果要传送整个文件夹内的所有数据，还需要额外添加参数-r进行递归操作。然后写上要传送到的远程主机的IP地址，远程服务器便会要求进行身份验证了。当前用户名称为root，而密码则为远程服务器的密码。如果想使用指定用户的身份进行验证，可使用用户名@主机地址的参数格式。最后需要在远程主机的IP地址后面添加冒号，并在后面写上要传送到远程主机的哪个文件夹中。只要参数正确并且成功验证了用户身份，即可开始传送工作。</p><p>此外，还可以使用scp命令把远程主机上的文件下载到本地主机，其命令格式为“scp [参数] 远程用户@远程IP地址:远程文件 本地目录”。</p><h3 id="不间断会话服务"><a href="#不间断会话服务" class="headerlink" title="不间断会话服务"></a>不间断会话服务</h3><h4 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h4><p>screen是一款能够实现多窗口远程控制的开源服务程序，简单来说就是为了解决网络异常中断或为了同时控制多个远程终端窗口而设计的程序。用户还可以使用screen服务程序同时在多个远程会话中自由切换，能够做到实现如下功能</p><blockquote><p><strong>会话恢复</strong>：即便网络中断，也可让会话随时恢复，确保用户不会失去对远程会话的控制。</p><p><strong>多窗口</strong>：每个会话都是独立运行的，拥有各自独立的输入输出终端窗口，终端窗口内显示过的信息也将被分开隔离保存，以便下次使用时依然能看到之前的操作记录。</p><p><strong>会话共享</strong>：当多个用户同时登录到远程服务器时，便可以使用会话共享功能让用户之间的输入输出信息共享。</p></blockquote><h5 id="管理远程会话"><a href="#管理远程会话" class="headerlink" title="管理远程会话"></a>管理远程会话</h5><blockquote><p>screen -S 创建会话窗口；</p><p>screen -d 将指定会话进行离线处理；</p><p>screen -r 恢复指定会话；</p><p>screen -x 一次性恢复所有的会话；</p><p>screen -ls 显示当前已有的会话；</p><p>screen -wipe 把目前无法使用的会话删除。</p><p>……</p></blockquote><h5 id="会话共享功能"><a href="#会话共享功能" class="headerlink" title="会话共享功能"></a>会话共享功能</h5><p>screen命令不仅可以确保用户在极端情况下也不丢失对系统的远程控制，保证了生产环境中远程工作的不间断性，而且它还具有会话共享、分屏切割、会话锁定等实用的功能。其中，会话共享功能是一件很酷的事情，当多个用户同时控制主机的时候，它可以把屏幕内容共享出来，也就是说每个用户都可以看到相同的内容。<br><img src="https://img.sunjingdong.com/FjzFkdSGYJLGV0p1lWRprBaotGg0"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习 第十天</title>
      <link href="linux-xue-xi-di-shi-tian.html"/>
      <url>linux-xue-xi-di-shi-tian.html</url>
      
        <content type="html"><![CDATA[<h2 id="iptables与firewalld防火墙"><a href="#iptables与firewalld防火墙" class="headerlink" title="iptables与firewalld防火墙"></a>iptables与firewalld防火墙</h2><h3 id="配置网卡的4种方法"><a href="#配置网卡的4种方法" class="headerlink" title="配置网卡的4种方法"></a>配置网卡的4种方法</h3><h4 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1.修改配置文件"></a>1.修改配置文件</h4><p>​    /etc/sysconfig/network-scripts/ifcfg-enoxxxx，保存后重启网卡 systemctl restart network</p><h4 id="2-nmtui"><a href="#2-nmtui" class="headerlink" title="2.nmtui"></a>2.nmtui</h4><p>​    RHEL 5/6 版本里是setup，7/8 版本里是nutui</p><h4 id="3-nm-connection-editor"><a href="#3-nm-connection-editor" class="headerlink" title="3.nm-connection-editor"></a>3.nm-connection-editor</h4><h4 id="4-桌面右上角网卡图标"><a href="#4-桌面右上角网卡图标" class="headerlink" title="4.桌面右上角网卡图标"></a>4.桌面右上角网卡图标</h4><p>​    设置完后重新开关一下网卡</p><h2 id="防火墙管理工具"><a href="#防火墙管理工具" class="headerlink" title="防火墙管理工具"></a>防火墙管理工具</h2><p>iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已，或者说，它们只是一种服务：<br>iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理；<br>firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。<br>虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的</p><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>RHEL 7.1 版本后就没有了</p><h3 id="策略与规则链"><a href="#策略与规则链" class="headerlink" title="策略与规则链"></a>策略与规则链</h3><p>防火墙会从上至下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。一般而言，防火墙策略规则的设置有两种：一种是“通”（即放行），一种是“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许时，就要设置拒绝规则，否则谁都能进来，防火墙也就失去了防范的作用。</p><p>iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，</p><blockquote><p>在进行路由选择前处理数据包（PREROUTING）；</p><p>处理流入的数据包（INPUT）；</p><p>处理流出的数据包（OUTPUT）；</p><p>处理转发的数据包（FORWARD）；</p><p>在进行路由选择后处理数据包（POSTROUTING）。</p></blockquote><h3 id="iptalbes基本命令"><a href="#iptalbes基本命令" class="headerlink" title="iptalbes基本命令"></a>iptalbes基本命令</h3><p> iptables中常用的参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-P</td><td>设置默认策略</td></tr><tr><td>-F</td><td>清空规则链</td></tr><tr><td>-L</td><td>查看规则链</td></tr><tr><td>-A</td><td>在规则链的末尾加入新规则</td></tr><tr><td>-I num</td><td>在规则链的头部加入新规则</td></tr><tr><td>-D num</td><td>删除某一条规则</td></tr><tr><td>-s</td><td>匹配来源地址IP/MASK，加叹号“!”表示除这个IP外</td></tr><tr><td>-d</td><td>匹配目标地址</td></tr><tr><td>-i 网卡名称</td><td>匹配从这块网卡流入的数据</td></tr><tr><td>-o 网卡名称</td><td>匹配从这块网卡流出的数据</td></tr><tr><td>-p</td><td>匹配协议，如TCP、UDP、ICMP</td></tr><tr><td>–dport num</td><td>匹配目标端口号</td></tr><tr><td>–sport num</td><td>匹配来源端口号</td></tr></tbody></table><h2 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h2><p>RHEL 7系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。</p><p>firewalld支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。</p><h3 id="firewalld中常用的区域名称及策略规则"><a href="#firewalld中常用的区域名称及策略规则" class="headerlink" title="firewalld中常用的区域名称及策略规则"></a>firewalld中常用的区域名称及策略规则</h3><table><thead><tr><th>区域</th><th>默认规则策略</th></tr></thead><tbody><tr><td>trusted</td><td>允许所有的数据包</td></tr><tr><td>home</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量</td></tr><tr><td>internal</td><td>等同于home区域</td></tr><tr><td>work</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量</td></tr><tr><td>public</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量</td></tr><tr><td>external</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td></tr><tr><td>dmz</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td></tr><tr><td>block</td><td>拒绝流入的流量，除非与流出的流量相关</td></tr><tr><td>drop</td><td>拒绝流入的流量，除非与流出的流量相关</td></tr></tbody></table><h2 id="终端管理工具"><a href="#终端管理工具" class="headerlink" title="终端管理工具"></a>终端管理工具</h2><h3 id="firewall-cmd"><a href="#firewall-cmd" class="headerlink" title="firewall-cmd"></a>firewall-cmd</h3><p>firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本，它的参数一般都是以“长格式”来提供的</p><p>firewall-cmd命令中使用的参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>–get-default-zone</td><td>查询默认的区域名称</td></tr><tr><td>–set-default-zone=&lt;区域名称&gt;</td><td>设置默认的区域，使其永久生效</td></tr><tr><td>–get-zones</td><td>显示可用的区域</td></tr><tr><td>–get-services</td><td>显示预先定义的服务</td></tr><tr><td>–get-active-zones</td><td>显示当前正在使用的区域与网卡名称</td></tr><tr><td>–add-source=</td><td>将源自此IP或子网的流量导向指定的区域</td></tr><tr><td>–remove-source=</td><td>不再将源自此IP或子网的流量导向某个指定区域</td></tr><tr><td>–add-interface=&lt;网卡名称&gt;</td><td>将源自该网卡的所有流量都导向某个指定区域</td></tr><tr><td>–change-interface=&lt;网卡名称&gt;</td><td>将某个网卡与区域进行关联</td></tr><tr><td>–list-all</td><td>显示当前区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td>–list-all-zones</td><td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td>–add-service=&lt;服务名&gt;</td><td>设置默认区域允许该服务的流量</td></tr><tr><td>–add-port=&lt;端口号/协议&gt;</td><td>设置默认区域允许该端口的流量</td></tr><tr><td>–remove-service=&lt;服务名&gt;</td><td>设置默认区域不再允许该服务的流量</td></tr><tr><td>–remove-port=&lt;端口号/协议&gt;</td><td>设置默认区域不再允许该端口的流量</td></tr><tr><td>–reload</td><td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td></tr><tr><td>–panic-on</td><td>开启应急状况模式</td></tr><tr><td>–panic-off</td><td>关闭应急状况模式</td></tr></tbody></table><p>与Linux系统中其他的防火墙策略配置工具一样，使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加–permanent参数，这样配置的防火墙策略就可以永久生效了。设置的策略只有在系统重启之后才能自动生效。如果想让配置的策略立即生效，需要手动执行firewall-cmd –reload命令。</p><h2 id="图形管理工具"><a href="#图形管理工具" class="headerlink" title="图形管理工具"></a>图形管理工具</h2><h3 id="firewall-config"><a href="#firewall-config" class="headerlink" title="firewall-config"></a>firewall-config</h3><p>​    firewalld防火墙配置管理工具的GUI（图形用户界面）版本，几乎可以实现所有以命令行来执行的操作</p><p><strong>1</strong>：选择运行时（Runtime）模式或永久（Permanent）模式的配置。</p><p><strong>2</strong>：可选的策略集合区域列表。</p><p><strong>3</strong>：常用的系统服务列表。</p><p><strong>4</strong>：当前正在使用的区域。</p><p><strong>5</strong>：管理当前被选中区域中的服务。</p><p><strong>6</strong>：管理当前被选中区域中的端口。</p><p><strong>7</strong>：开启或关闭SNAT（源地址转换协议）技术。</p><p><strong>8</strong>：设置端口转发策略。</p><p><strong>9</strong>：控制请求icmp服务的流量。</p><p><strong>10</strong>：管理防火墙的富规则。</p><p><strong>11</strong>：管理网卡设备。</p><p><strong>12</strong>：被选中区域的服务，若勾选了相应服务前面的复选框，则表示允许与之相关的流量。</p><p><strong>13</strong>：firewall-config工具的运行状态。<br><img src="https://img.sunjingdong.com/FsCCZFa0W8RhGNvH7YZlVXKGXdhf"></p><h2 id="服务的访问控制列表"><a href="#服务的访问控制列表" class="headerlink" title="服务的访问控制列表"></a>服务的访问控制列表</h2><h3 id="TCP-Wrappers"><a href="#TCP-Wrappers" class="headerlink" title="TCP Wrappers"></a>TCP Wrappers</h3><p>TCP Wrappers是RHEL 7系统中默认启用的一款流量监控程序，它能够根据来访主机的地址与本机的目标服务程序作出允许或拒绝的操作。换句话说，Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrappers服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。</p><p>TCP Wrappers服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文件来放行对服务的请求流量，也可以编辑拒绝控制列表文件来阻止对服务的请求流量。控制列表文件修改后会立即生效，系统将会先检查允许控制列表文件（/etc/hosts.allow），如果匹配到相应的允许策略则放行流量；如果没有匹配，则去进一步匹配拒绝控制列表文件（/etc/hosts.deny），若找到匹配项则拒绝该流量。如果这两个文件全都没有匹配到，则默认放行流量。</p><p> TCP Wrappers服务的控制列表文件中常用的参数</p><table><thead><tr><th>客户端类型</th><th>示例</th><th>满足示例的客户端列表</th></tr></thead><tbody><tr><td>单一主机</td><td>192.168.10.10</td><td>IP地址为192.168.10.10的主机</td></tr><tr><td>指定网段</td><td>192.168.10.</td><td>IP段为192.168.10.0/24的主机</td></tr><tr><td>指定网段</td><td>192.168.10.0/255.255.255.0</td><td>IP段为192.168.10.0/24的主机</td></tr><tr><td>指定DNS后缀</td><td>.linuxprobe.com</td><td>所有DNS后缀为.linuxprobe.com的主机</td></tr><tr><td>指定主机名称</td><td><a href="http://www.linuxprobe.com/">www.linuxprobe.com</a></td><td>主机名称为<a href="http://www.linuxprobe.com的主机/">www.linuxprobe.com的主机</a></td></tr><tr><td>指定所有客户端</td><td>ALL</td><td>所有主机全部包括在内</td></tr></tbody></table><p>在配置TCP Wrappers服务时需要遵循两个原则：</p><ol><li>编写拒绝策略规则时，填写的是服务名称，而非协议名称；</li><li>建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。<br><img src="https://img.sunjingdong.com/FmYLmSe6Yv07Zq1Fp7D9yeLqpZ2u"></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习 第九天</title>
      <link href="linux-xue-xi-di-jiu-tian.html"/>
      <url>linux-xue-xi-di-jiu-tian.html</url>
      
        <content type="html"><![CDATA[<p>2020年5月17日 周日</p><h2 id="软硬方式链接"><a href="#软硬方式链接" class="headerlink" title="软硬方式链接"></a>软硬方式链接</h2><p><strong>硬链接（hard link）：</strong> 可以将它理解为一个“指向原始文件inode的指针”，系统不为它分配独立的inode和文件。所以，硬链接文件与原始文件其实是同一个文件，只是名字不同。我们每添加一个硬链接，该文件的inode连接数就会增加1；而且只有当该文件的inode连接数为0时，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件inode的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，由于技术的局限性，我们不能跨分区对目录文件进行链接。</p><p><strong>软链接（也称为符号链接[symbolic link]）：</strong> 仅仅包含所链接文件的路径名，因此能链接目录文件，也可以跨越文件系统进行链接。但是，当原始文件被删除后，链接文件也将失效，从这一点上来说与Windows系统中的“快捷方式”具有一样的性质。</p><h5 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h5><p>ln命令用于创建链接文件，格式为“ln [选项] 目标”，其可用的参数以及作用如表6-6所示。在使用ln命令时，是否添加-s参数，将创建出性质不同的两种“快捷方式”。</p><p>ln命令中可用的参数以及作用</p><table><thead><tr><th>参数</th><th align="left">作用</th></tr></thead><tbody><tr><td>-s</td><td align="left">创建“符号链接”（如果不带-s参数，则默认创建硬链接）</td></tr><tr><td>-f</td><td align="left">强制创建文件或目录的链接</td></tr><tr><td>-i</td><td align="left">覆盖前先询问</td></tr><tr><td>-v</td><td align="left">显示创建链接的过程</td></tr></tbody></table><h2 id="RAID与LVM"><a href="#RAID与LVM" class="headerlink" title="RAID与LVM"></a>RAID与LVM</h2><h3 id="RAID（独立冗余磁盘阵列）"><a href="#RAID（独立冗余磁盘阵列）" class="headerlink" title="RAID（独立冗余磁盘阵列）"></a>RAID（独立冗余磁盘阵列）</h3><p>RAID技术通过把多个硬盘设备组合成一个容量更大、安全性更好的磁盘阵列，并把数据切割成多个区段后分别存放在各个不同的物理硬盘设备上，然后利用分散读写技术来提升磁盘阵列整体的性能，同时把多个重要数据的副本同步到不同的物理硬盘设备上，从而起到了非常好的数据冗余备份效果，但是它也相应地提高了成本支出。</p><h4 id="常用RAID方案"><a href="#常用RAID方案" class="headerlink" title="常用RAID方案"></a>常用RAID方案</h4><p>RAID 0、RAID 1、RAID 5、RAID 10</p><h5 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h5><p>RAID0技术把多块物理硬盘设备（至少两块）通过硬件或软件的方式串联在一起，组成一个大的卷组，并将数据依次写入到各个物理硬盘中。这样一来，在最理想的状态下，硬盘设备的读写性能会提升数倍，但是若任意一块硬盘发生故障将导致整个系统的数据都受到破坏。通俗来说，RAID 0技术能够有效地提升硬盘数据的吞吐速度，但是不具备数据备份和错误修复能力。如图7-1所示，数据被分别写入到不同的硬盘设备中，即disk1和disk2硬盘设备会分别保存数据资料，最终实现提升读取、写入速度的效果。<br><img src="https://img.sunjingdong.com/Fn_QsFqCceb6uv27AcvvYgpd-TnM"></p><h5 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h5><p>尽管RAID 0技术提升了硬盘设备的读写速度，但是它是将数据依次写入到各个物理硬盘中，也就是说，它的数据是分开存放的，其中任何一块硬盘发生故障都会损坏整个系统的数据。因此，如果生产环境对硬盘设备的读写速度没有要求，而是希望增加数据的安全性时，就需要用到RAID 1技术了。<br><img src="https://img.sunjingdong.com/FmQ1vIw4-qWVWuiBy5fro7jLgCAX"></p><p>如图所示，它是把两块以上的硬盘设备进行绑定，在写入数据时，是将数据同时写入到多块硬盘设备上（可以将其视为数据的镜像或备份）。当其中某一块硬盘发生故障后，一般会立即自动以热交换的方式来恢复数据的正常使用。</p><h5 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h5><p>RAID5技术是把硬盘设备的数据奇偶校验信息保存到其他硬盘设备中。RAID 5磁盘阵列组中数据的奇偶校验信息并不是单独保存到某一块硬盘设备中，而是存储到除自身以外的其他每一块硬盘设备上，这样的好处是其中任何一设备损坏后不至于出现致命缺陷；图7-3中parity部分存放的就是数据的奇偶校验信息，换句话说，就是RAID 5技术实际上没有备份硬盘中的真实数据信息，而是当硬盘设备出现问题后通过奇偶校验信息来尝试重建损坏的数据。RAID这样的技术特性“妥协”地兼顾了硬盘设备的读写速度、数据安全性与存储成本问题。<br><img src="https://img.sunjingdong.com/Fio244y0JU9ojfG12oAGUmgcVFEG"></p><h5 id="RAID-10"><a href="#RAID-10" class="headerlink" title="RAID 10"></a>RAID 10</h5><p>鉴于RAID 5技术是因为硬盘设备的成本问题对读写速度和数据的安全性能而有了一定的妥协，但是大部分企业更在乎的是数据本身的价值而非硬盘价格，因此生产环境中主要使用RAID 10技术。<br><img src="https://img.sunjingdong.com/FuNmWiSEuW1Ci2tUKZWhIEun3eHQ"></p><p>顾名思义，RAID 10技术是RAID 1+RAID 0技术的一个“组合体”。如图7-4所示，RAID 10技术需要至少4块硬盘来组建，其中先分别两两制作成RAID 1磁盘阵列，以保证数据的安全性；然后再对两个RAID 1磁盘阵列实施RAID 0技术，进一步提高硬盘设备的读写速度。这样从理论上来讲，只要坏的不是同一组中的所有硬盘，那么最多可以损坏50%的硬盘设备而不丢失数据。由于RAID 10技术继承了RAID 0的高读写速度和RAID 1的数据安全性，在不考虑成本的情况下RAID 10的性能都超过了RAID 5，因此当前成为广泛使用的一种存储技术。</p><h3 id="部署磁盘阵列"><a href="#部署磁盘阵列" class="headerlink" title="部署磁盘阵列"></a>部署磁盘阵列</h3><p>mdadm命令用于管理Linux系统中的软件RAID硬盘阵列，格式为“mdadm [模式] &lt;RAID设备名称&gt; [选项] [成员设备名称]”。</p><p>mdadm命令的常用参数和作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>检测设备名称</td></tr><tr><td>-n</td><td>指定设备数量</td></tr><tr><td>-l</td><td>指定RAID级别</td></tr><tr><td>-C</td><td>创建</td></tr><tr><td>-v</td><td>显示过程</td></tr><tr><td>-f</td><td>模拟设备损坏</td></tr><tr><td>-r</td><td>移除设备</td></tr><tr><td>-Q</td><td>查看摘要信息</td></tr><tr><td>-D</td><td>查看详细信息</td></tr><tr><td>-S</td><td>停止RAID磁盘阵列</td></tr></tbody></table><h3 id="LVM（逻辑卷管理器）"><a href="#LVM（逻辑卷管理器）" class="headerlink" title="LVM（逻辑卷管理器）"></a>LVM（逻辑卷管理器）</h3><p>LVM可以允许用户对硬盘资源进行动态调整，LVM技术是在硬盘分区和文件系统之间添加了一个逻辑层，它提供了一个抽象的卷组，可以把多块硬盘进行卷组合并。这样一来，用户不必关心物理硬盘设备的底层架构和布局，就可以实现对硬盘分区的动态调整。<br><img src="https://img.sunjingdong.com/FiNbEcriDs35P7xghHMr-1SGDctr"></p><h4 id="常用的LVM部署命令"><a href="#常用的LVM部署命令" class="headerlink" title="常用的LVM部署命令"></a>常用的LVM部署命令</h4><table><thead><tr><th>功能/命令</th><th>物理卷管理</th><th>卷组管理</th><th>逻辑卷管理</th></tr></thead><tbody><tr><td>扫描</td><td>pvscan</td><td>vgscan</td><td>lvscan</td></tr><tr><td>建立</td><td>pvcreate</td><td>vgcreate</td><td>lvcreate</td></tr><tr><td>显示</td><td>pvdisplay</td><td>vgdisplay</td><td>lvdisplay</td></tr><tr><td>删除</td><td>pvremove</td><td>vgremove</td><td>lvremove</td></tr><tr><td>扩展</td><td></td><td>vgextend</td><td>lvextend</td></tr><tr><td>缩小</td><td></td><td>vgreduce</td><td>lvreduce</td></tr></tbody></table><p><img src="https://img.sunjingdong.com/FngRQV55QxppCZsDWUqMXxSLKG-N"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习 第八天</title>
      <link href="linux-xue-xi-di-ba-tian.html"/>
      <url>linux-xue-xi-di-ba-tian.html</url>
      
        <content type="html"><![CDATA[<p>2020年5月16日 周六<br>存储结构与磁盘划分</p><p>在Linux系统中，目录、字符设备、块设备、套接字、打印机等都被抽象成了文件，即刘遄老师所一直强调的“Linux系统中一切都是文件”。既然平时我们打交道的都是文件，那么又应该如何找到它们呢？在Windows操作系统中，想要找到一个文件，我们要依次进入该文件所在的磁盘分区（假设这里是D盘），然后在进入该分区下的具体目录，最终找到这个文件。但是在Linux系统中并不存在C/D/E/F等盘符，Linux系统中的一切文件都是从“根（/）”目录开始的，并按照文件系统层次化标准（FHS）采用树形结构来存放文件，以及定义了常见目录的用途。另外，Linux系统中的文件和目录名称是严格区分大小写的。例如，root、rOOt、Root、rooT均代表不同的目录，并且文件名称中不得包含斜杠（/）。<br><img src="https://img.sunjingdong.com/FhKezib_jhvuhGxcOL_Kjl3HRAuf"><br>Linux系统中常见的目录名称以及相应内容</p><table><thead><tr><th>目录名称</th><th>应放置文件的内容</th></tr></thead><tbody><tr><td>/boot</td><td>开机所需文件—内核、开机菜单以及所需配置文件等</td></tr><tr><td>/dev</td><td>以文件形式存放任何设备与接口</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/home</td><td>用户主目录</td></tr><tr><td>/bin</td><td>存放单用户模式下还可以操作的命令</td></tr><tr><td>/lib</td><td>开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数</td></tr><tr><td>/sbin</td><td>开机过程中需要的命令</td></tr><tr><td>/media</td><td>用于挂载设备文件的目录</td></tr><tr><td>/opt</td><td>放置第三方的软件</td></tr><tr><td>/root</td><td>系统管理员的家目录</td></tr><tr><td>/srv</td><td>一些网络服务的数据文件目录</td></tr><tr><td>/tmp</td><td>任何人均可使用的“共享”临时目录</td></tr><tr><td>/proc</td><td>虚拟文件系统，例如系统内核、进程、外部设备及网络状态等</td></tr><tr><td>/usr/local</td><td>用户自行安装的软件</td></tr><tr><td>/usr/sbin</td><td>Linux系统开机时不会使用到的软件/命令/脚本</td></tr><tr><td>/usr/share</td><td>帮助与说明文件，也可放置共享文件</td></tr><tr><td>/var</td><td>主要存放经常变化的文件，如日志</td></tr><tr><td>/lost+found</td><td>当文件系统发生错误时，将一些丢失的文件片段存放在这里</td></tr></tbody></table><p>常见的硬件设备及其文件名称</p><table><thead><tr><th>硬件设备</th><th>文件名称</th></tr></thead><tbody><tr><td>IDE设备</td><td>/dev/hd[a-d]</td></tr><tr><td>SCSI/SATA/U盘</td><td>/dev/sd[a-p]</td></tr><tr><td>软驱</td><td>/dev/fd[0-1]</td></tr><tr><td>打印机</td><td>/dev/lp[0-15]</td></tr><tr><td>光驱</td><td>/dev/cdrom</td></tr><tr><td>鼠标</td><td>/dev/mouse</td></tr><tr><td>磁带机</td><td>/dev/st0或/dev/ht0</td></tr></tbody></table><p>由于现在的IDE设备已经很少见了，所以一般的硬盘设备都会是以“/dev/sd”开头的。而一台主机上可以有多块硬盘，因此系统采用a～p来代表16块不同的硬盘（默认从a开始分配），而且硬盘的分区编号也很有讲究：</p><blockquote><p>主分区或扩展分区的编号从1开始，到4结束；<br>逻辑分区从编号5开始。</p></blockquote><p>第一个知识点是/dev目录中sda设备之所以是a，并不是由插槽决定的，而是由系统内核的识别顺序来决定的，而恰巧很多主板的插槽顺序就是系统内核的识别顺序，因此才会被命名为/dev/sda。大家以后在使用iSCSI网络存储设备时就会发现，明明主板上第二个插槽是空着的，但系统却能识别到/dev/sdb这个设备就是这个道理。</p><p>第二个知识点是对分区名称的理解错误。比如sda3表示这是设备上的第三个分区，而学员在做实验的时候确实也会得出这样的结果，但是这个理论知识是错误的，因为分区的数字编码不一定是强制顺延下来的，也有可能是手工指定的。因此sda3只能表示是编号为3的分区，而不能判断sda设备上已经存在了3个分区。<br><img src="https://img.sunjingdong.com/FjTcjA6uPTnFYFoLwFGoLBNL99yj"><br><img src="https://img.sunjingdong.com/FmRVI0iWWl1tvfnySjiFJfsbz5Ik"><br><img src="https://img.sunjingdong.com/FkUJs3unNVj4c3WMBW2dmZSKzQLU"><br><img src="https://img.sunjingdong.com/FsFsXTR_6v68aGD3OR4v74aJsj2a"><br><img src="https://img.sunjingdong.com/FqBSzODKeFrn8X5v-jBwkfr47_r1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习 第七天</title>
      <link href="linux-xue-xi-di-qi-tian.html"/>
      <url>linux-xue-xi-di-qi-tian.html</url>
      
        <content type="html"><![CDATA[<p>2020年5月15日 周五<br>文件权限与归属</p><blockquote><p>-：普通文件<br>d：目录文件<br>l：链接文件<br>b：块设备文件<br>c：字符设备文件<br>p：管道文件</p></blockquote><p>在Linux系统中，每个文件都有所属的所有者和所有组，并且规定了文件的所有者、所有组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。</p><p>对目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p>文件的读、写、执行权限可以简写为rwx，亦可分别用数字4、2、1来表示，文件所有者，所属组及其他用户权限之间无关联。<br><img src="https://img.sunjingdong.com/Fohvh48o5FiN3DNlQ0f4XIswtPVC"><br>文件权限的数字法表示基于字符表示（rwx）的权限计算而来，其目的是简化权限的表示。例如，若某个文件的权限为7则代表可读、可写、可执行（4+2+1）；若权限为6则代表可读、可写（4+2）。我们来看这样一个例子。现在有这样一个文件，其所有者拥有可读、可写、可执行的权限，其文件所属组拥有可读、可写的权限；而且其他人只有可读的权限。那么，这个文件的权限就是rwxrw-r–，数字法表示即为764。不过大家千万别再将这三个数字相加，计算出7+6+4=17的结果，这是小学的数学加减法，不是Linux系统的权限数字表示法，三者之间没有互通关系。<br><img src="https://img.sunjingdong.com/FtZCz5RNmAJbcwrnlwabe1djMS8t"><br><img src="https://img.sunjingdong.com/Fpss-0jlbDSin5guBgDp36oOssiK"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习 第六天</title>
      <link href="linux-xue-xi-di-liu-tian.html"/>
      <url>linux-xue-xi-di-liu-tian.html</url>
      
        <content type="html"><![CDATA[<p>2020年5月10日 周日<br>for条件循环语句<br>for循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理，当要处理的数据有范围时，使用for循环语句再适合不过了。<br><img src="https://img.sunjingdong.com/FpNplzeNt8qF3_iBYUVQuLMvdLtg"><br><img src="https://img.sunjingdong.com/FsssnPI-D81vz6P5oqCGY8VmIOh_"><br><img src="https://img.sunjingdong.com/Fm6uaLZQ4DavNxrEw6XKgjTzSbKh"><br><img src="https://img.sunjingdong.com/Fi_w4fvrlozSIK7zXZwByZoG83kx"><br><img src="https://img.sunjingdong.com/FkMuA8cQENKuJPsSsSNB-4RCscNH"><br><img src="https://img.sunjingdong.com/FuC6QMvPVi8TTZsSGmgVKjrzGB0z"><br>用户身份与文件权限<br>Linux是一个多用户、多任务的操作系统，具有很好的稳定性与安全性，在幕后保障Linux系统安全的则是一系列复杂的配置工作。本章将详细讲解文件的所有者、所属组以及其他人可对文件进行的读（r）、写（w）、执行（x）等操作，以及如何在Linux系统中添加、删除、修改用户账户信息。我们还可以使用SUID、SGID与SBIT特殊权限更加灵活地设置系统权限功能，来弥补对文件设置一般操作权限时所带来的不足。隐藏权限能够给系统增加一层隐形的防护层，让黑客最多只能查看关键日志信息，而不能进行修改或删除。而文件的访问控制列表（Access Control List，ACL）可以进一步让单一用户、用户组对单一文件或目录进行特殊的权限设置，让文件具有能满足工作需求的最小权限。本章最后还将讲解如何使用su命令与sudo服务让普通用户具备管理员的权限，不仅可以满足日常的工作需求，还可以确保系统的安全性。</p><blockquote><p>管理员UID为0：系统的管理员用户。<br>系统用户UID为1～999： Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会有独立的系统用户负责运行，进而有效控制被破坏范围。<br>普通用户UID从1000开始：是由管理员创建的用于日常工作的用户。</p></blockquote><p><img src="https://img.sunjingdong.com/Fggg3MTkxyEL7laibtJyQFrMHbea"><br><img src="https://img.sunjingdong.com/FkPhRWwLDetI7-DPW9AnPa1dvBxV"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习 第五天</title>
      <link href="linux-xue-xi-di-wu-tian.html"/>
      <url>linux-xue-xi-di-wu-tian.html</url>
      
        <content type="html"><![CDATA[<p>2020年5月9日 周六</p><h3 id="Vim编辑器"><a href="#Vim编辑器" class="headerlink" title="Vim编辑器"></a>Vim编辑器</h3><p>“在Linux系统中一切都是文件，而配置一个服务就是在修改其配置文件的参数”。而且在日常工作中大家也肯定免不了要编写文档，这些工作都是通过文本编辑器来完成的。<br>Vim之所以能得到广大厂商与用户的认可，原因在于Vim编辑器中设置了三种模式—命令模式、末行模式和编辑模式，每种模式分别又支持多种不同的命令快捷键，这大大提高了工作效率，而且用户在习惯之后也会觉得相当顺手。要想高效率地操作文本，就必须先搞清这三种模式的操作区别以及模式之间的切换方法<br><img src="https://img.sunjingdong.com/FlFjxh94qmS3iki8O0MdMM_TqS30"><br>命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。<br>输入模式：正常的文本录入。<br>末行模式：保存或退出文档，以及设置编辑环境。</p><h3 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p><img src="https://img.sunjingdong.com/FgiPRJgl1y8ojYHMxe4EBL2oOJsU"><br><img src="https://img.sunjingdong.com/FpJd55PLTd9ZLJzn-L6swvXGiaho"><br><img src="https://img.sunjingdong.com/Fklo77j2RL32LpGKdAyZU4Y0bo5d"><br><img src="https://img.sunjingdong.com/FuDcmYj3rng2QUgusFqUWMrJNO7u"><br><img src="https://img.sunjingdong.com/FiT2diuvkAt7vpaIOj5phamRzQUo"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习 第四天</title>
      <link href="linux-xue-xi-di-si-tian.html"/>
      <url>linux-xue-xi-di-si-tian.html</url>
      
        <content type="html"><![CDATA[<p>2020年5月8日 周五</p><blockquote><p>tar命令-对文件打包或者解压<br>tar czvf 打包<br>tar xzvf 解压 后缀名为.tar.gz 或 .tar.bz2<br>tar xvf 自动识别后缀解压<br>默认解压到当前目录，加-C参数，指定解压目录</p></blockquote><p><img src="https://img.sunjingdong.com/Fn5XUQAXyZV1I6pNLu0lKS8yt0iT"><br><img src="https://img.sunjingdong.com/Fg1rGvnT3KEpwcqDNeHdJ31m44nn"><br>grep-用于在文本中执行关键词搜索，并显示匹配结果<br>-n参数显示行号，-v参数用于反选信息</p><p>find命令-按照指定条件查找文件，find的参数都是长格式，但只有一个-</p><p>重定向<br>1.标准输入重定向<br>命令 &lt; 文件<br>2.输出重定向<br>2.1标准输出重定向<br>命令 &gt; 文件 覆盖输出<br>命令 &gt;&gt; 文件 追加输出<br>2.2错误输出重定向<br>命令 2&gt; 文件 错误覆盖输出<br>命令 2&gt;&gt; 文件 错误追加输出<br>&amp;&gt; 文件 将标准输出与错误输出共同写入到文件，覆盖原有内容<br>&amp;&gt;&gt; 文件 追加到原有内容后面<br><img src="https://img.sunjingdong.com/FmJrd1r1cJeTFU99asIj6hDlBLuE"><br>管道符（任意门） |<br>echo linuxprobe | passwd –stdin 用户名 修改用户密码</p><p>通配符<br>*匹配空值或者无穷多的信息<br>?有且必须匹配一个字符<br>[a-z] 匹配小写字母<br>[A-Z]匹配大写字母<br>[a,c,e]匹配指定的字母<br>[0-9]匹配<br>[1,3,5]匹配指定的数字<br><img src="https://img.sunjingdong.com/FodVEiZ6vM6NRhxUaN8MdoKeLCo9"><br>转义字符<br>对象中有空格，一定要加双引号””<br><img src="https://img.sunjingdong.com/Fndr2b1vcgNmyfRQAu99O3Y0Ij6k"><br>环境变量<br>alias 别名 下次重启前有效<br>别名永久生效方法，编辑/etc/profile 或 ~/.bashrc</p><p>export 变量 将变量提升为全局变量，所有用户都可使用<br><img src="https://img.sunjingdong.com/FnJNEIpFhVtjJyFJ3vu5NWW3O9fW"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习 第三天</title>
      <link href="linux-xue-xi-di-san-tian.html"/>
      <url>linux-xue-xi-di-san-tian.html</url>
      
        <content type="html"><![CDATA[<p>2020年5月3日 周日<br>继续讲解了常用的系统命令，这些命令需要记住</p><blockquote><p>ifconfig 查看网卡配置与网络状态<br>uname 查看系统内核与系统版本，uname -a 搭配-a参数完整查看信息<br>uptime 查看系统负载信息，相当于top命令第一行内容<br>free 显示系统内存使用量信息，一般使用free -h，更人性化的显示信息<br>who 查看当前登入主机的用户终端信息，:0是图形界面终端，pts/0是文字界面<br>last 查看系统的登陆记录，不推荐以此为准，因为黑客可以修改，仅供参考<br>history 显示历史执行过的命令，最近1000条记录，（!+数字）可以重复执行某一次命令<br>sosreport 收集系统配置架构信息并输出诊断文档<br>pwd 显示当前所处的目录<br>cd 切换工作路径，cd … 进入上级目录，cd ~ 进入当前用户家目录，cd - 返回到上一次所处目录<br>…</p></blockquote><p><img src="https://img.sunjingdong.com/FtEuo7flNd6lvuGMZyiODmfV0ahu"><br><img src="https://img.sunjingdong.com/Fu8ITfRigrhUPM3r69bIRZc77-HD"><br><img src="https://img.sunjingdong.com/FmF7nexbDojf_X4pX9Pn9p6h023I"><br><img src="https://img.sunjingdong.com/Fhzd6EpsCGlhCKIZm4s8ebPY-U7F"><br><img src="https://img.sunjingdong.com/Fukvgii-4sWTjEJUh4H-tTIzUz8F"><br><img src="https://img.sunjingdong.com/Fka6SIqbQU5P0WmX9CQb5ZzMOL0P"><br><img src="https://img.sunjingdong.com/FqNOXa68wYJnZYbKA2uFd9PNdVmL"><br><img src="https://img.sunjingdong.com/FizKcfyENVGDdGzpiaZx04ksKTKI"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习 第二天</title>
      <link href="linux-xue-xi-di-er-tian.html"/>
      <url>linux-xue-xi-di-er-tian.html</url>
      
        <content type="html"><![CDATA[<p>2020年5月2日 周六<br><strong>安装配置VM虚拟机，安装RHEL7系统，以及安装时的注意事项<br>学习了一些简单的命令：</strong></p><blockquote><p>echo<br>date<br>reboot<br>poweroff<br>wget<br>ps<br>top<br>pidof<br>kill<br>killall<br>等等</p></blockquote><p><img src="https://img.sunjingdong.com/FoTZ6DqFQpffrVhMmGvBrs2kE5Ky"><br><img src="https://img.sunjingdong.com/Fot4k3paT5SddY0UfPukBuvkdr1P"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习 第一天</title>
      <link href="linux-xue-xi-di-yi-tian.html"/>
      <url>linux-xue-xi-di-yi-tian.html</url>
      
        <content type="html"><![CDATA[<p>2020年5月1日 周五</p><p><strong>今天是课程第一天，主要介绍了开源的优势及Linux发展史，通过2个半小时的讲述，对开源共享精神有了进一步的了解，了解了Linux各发行版本和红帽认证。</strong><br><img src="https://img.sunjingdong.com/Fh0T8PV2fG1_gXhetkkcTIp36PPc" alt="image.png"></p><p><img src="https://img.sunjingdong.com/FlohcxdZQV5XjV-4J3s231wqKsLO"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
